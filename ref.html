<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Google Fonts - Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Marked.js for Markdown parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.2/marked.min.js"></script>
    <!-- Highlight.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- <link id="hljsTheme" rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css"> -->
    <!-- Socket.IO client for real-time communication -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <title>Professional Healthcare Assistant</title>
    <style>
        :root {
            /* Enhanced Color Palette */
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --success-gradient: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            --warning-gradient: linear-gradient(135deg, #fc4a1a 0%, #f7b733 100%);
            --danger-gradient: linear-gradient(135deg, #fc466b 0%, #3f5efb 100%);
            --info-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);

            /* Modern Color System */
            --primary-50: #f0f4ff;
            --primary-100: #e0e8ff;
            --primary-200: #c7d2fe;
            --primary-300: #a5b4fc;
            --primary-400: #818cf8;
            --primary-500: #667eea;
            --primary-600: #4f46e5;
            --primary-700: #4338ca;
            --primary-800: #3730a3;
            --primary-900: #312e81;

            /* Surface Colors */
            --surface-primary: rgba(255, 255, 255, 0.95);
            --surface-secondary: rgba(248, 250, 252, 0.9);
            --surface-accent: rgba(102, 126, 234, 0.05);
            --surface-glass: rgba(255, 255, 255, 0.15);

            /* Text Colors */
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-accent: #667eea;

            /* Shadows */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.08);
            --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.12);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.16);
            --shadow-xl: 0 16px 48px rgba(0, 0, 0, 0.24);

            /* Glass Effects */
            --glass-light: rgba(255, 255, 255, 0.25);
            --glass-medium: rgba(255, 255, 255, 0.15);
            --glass-dark: rgba(255, 255, 255, 0.1);

            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --radius-full: 50px;

            /* Animations */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.3s ease;
            --transition-slow: 0.5s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .markdown-list {
            margin-left: 32px;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: url('data:image/svg+xml;charset=utf-8;base64,PHN2ZyB3aWR0aD0nMTQ0MCcgaGVpZ2h0PScxMDI0JyB2aWV3Qm94PScwIDAgMTQ0MCAxMDI0JyBmaWxsPSdub25lJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnPjxnIGNsaXAtcGF0aD0ndXJsKCNjbGlwMF8xODlfMjYpJz48cmVjdCB3aWR0aD0nMTQ0MCcgaGVpZ2h0PScxMDI0JyBmaWxsPScjRjVGNUY1Jy8+PGcgZmlsdGVyPSd1cmwoI2ZpbHRlcjBfZl8xODlfMjYpJz48ZWxsaXBzZSBjeD0nOTA2LjUnIGN5PSc3MzUnIHJ4PSc3MzYuNScgcnk9JzcxNScgZmlsbD0nI0U0QUVFRCcvPjwvZz48ZyBmaWx0ZXI9J3VybCgjZmlsdGVyMV9kZGRpXzE4OV8yNiknPjxyZWN0IHdpZHRoPScxNDQwJyBoZWlnaHQ9JzEwMjQnIGZpbGw9J3VybCgjcGFpbnQwX2xpbmVhcl8xODlfMjYpJyBmaWxsLW9wYWNpdHk9JzAuNScvPjxyZWN0IHdpZHRoPScxNDQwJyBoZWlnaHQ9JzEwMjQnIGZpbGw9J3VybCgjcGFpbnQxX3JhZGlhbF8xODlfMjYpJyBmaWxsLW9wYWNpdHk9JzAuMScvPjxnIGZpbHRlcj0ndXJsKCNmaWx0ZXIyX2ZfMTg5XzI2KSc+PGVsbGlwc2UgY3g9JzM3My41JyBjeT0nMzc3JyByeD0nOTE2LjUnIHJ5PSc0NjUnIGZpbGw9JyNCNUMwRkQnLz48L2c+PC9nPjwvZz48ZGVmcz48ZmlsdGVyIGlkPSdmaWx0ZXIwX2ZfMTg5XzI2JyB4PSctMzAnIHk9Jy0xODAnIHdpZHRoPScxODczJyBoZWlnaHQ9JzE4MzAnIGZpbHRlclVuaXRzPSd1c2VyU3BhY2VPblVzZScgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSdzUkdCJz48ZmVGbG9vZCBmbG9vZC1vcGFjaXR5PScwJyByZXN1bHQ9J0JhY2tncm91bmRJbWFnZUZpeCcvPjxmZUJsZW5kIG1vZGU9J25vcm1hbCcgaW49J1NvdXJjZUdyYXBoaWMnIGluMj0nQmFja2dyb3VuZEltYWdlRml4JyByZXN1bHQ9J3NoYXBlJy8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0nMTAwJyByZXN1bHQ9J2VmZmVjdDFfZm9yZWdyb3VuZEJsdXJfMTg5XzI2Jy8+PC9maWx0ZXI+PGZpbHRlciBpZD0nZmlsdGVyMV9kZGRpXzE4OV8yNicgeD0nLTYwMycgeT0nLTExOCcgd2lkdGg9JzIxMDMnIGhlaWdodD0nMTIzMicgZmlsdGVyVW5pdHM9J3VzZXJTcGFjZU9uVXNlJyBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9J3NSR0InPjxmZUZsb29kIGZsb29kLW9wYWNpdHk9JzAnIHJlc3VsdD0nQmFja2dyb3VuZEltYWdlRml4Jy8+PGZlQ29sb3JNYXRyaXggaW49J1NvdXJjZUFscGhhJyB0eXBlPSdtYXRyaXgnIHZhbHVlcz0nMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAnIHJlc3VsdD0naGFyZEFscGhhJy8+PGZlT2Zmc2V0IGR5PSczMCcvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzMwJy8+PGZlQ29tcG9zaXRlIGluMj0naGFyZEFscGhhJyBvcGVyYXRvcj0nb3V0Jy8+PGZlQ29sb3JNYXRyaXggdHlwZT0nbWF0cml4JyB2YWx1ZXM9JzAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMSAwJy8+PGZlQmxlbmQgbW9kZT0nbm9ybWFsJyBpbjI9J0JhY2tncm91bmRJbWFnZUZpeCcgcmVzdWx0PSdlZmZlY3QxX2Ryb3BTaGFkb3dfMTg5XzI2Jy8+PGZlQ29sb3JNYXRyaXggaW49J1NvdXJjZUFscGhhJyB0eXBlPSdtYXRyaXgnIHZhbHVlcz0nMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAnIHJlc3VsdD0naGFyZEFscGhhJy8+PGZlT2Zmc2V0IGR5PScxNScvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzE1Jy8+PGZlQ29tcG9zaXRlIGluMj0naGFyZEFscGhhJyBvcGVyYXRvcj0nb3V0Jy8+PGZlQ29sb3JNYXRyaXggdHlwZT0nbWF0cml4JyB2YWx1ZXM9JzAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMDUgMCcvPjxmZUJsZW5kIG1vZGU9J25vcm1hbCcgaW4yPSdlZmZlY3QxX2Ryb3BTaGFkb3dfMTg5XzI2JyByZXN1bHQ9J2VmZmVjdDJfZHJvcFNoYWRvd18xODlfMjYnLz48ZmVDb2xvck1hdHJpeCBpbj0nU291cmNlQWxwaGEnIHR5cGU9J21hdHJpeCcgdmFsdWVzPScwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxMjcgMCcgcmVzdWx0PSdoYXJkQWxwaGEnLz48ZmVPZmZzZXQgZHk9JzUnLz48ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSc1Jy8+PGZlQ29tcG9zaXRlIGluMj0naGFyZEFscGhhJyBvcGVyYXRvcj0nb3V0Jy8+PGZlQ29sb3JNYXRyaXggdHlwZT0nbWF0cml4JyB2YWx1ZXM9JzAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMDUgMCcvPjxmZUJsZW5kIG1vZGU9J25vcm1hbCcgaW4yPSdlZmZlY3QyX2Ryb3BTaGFkb3dfMTg5XzI2JyByZXN1bHQ9J2VmZmVjdDNfZHJvcFNoYWRvd18xODlfMjYnLz48ZmVCbGVuZCBtb2RlPSdub3JtYWwnIGluPSdTb3VyY2VHcmFwaGljJyBpbjI9J2VmZmVjdDNfZHJvcFNoYWRvd18xODlfMjYnIHJlc3VsdD0nc2hhcGUnLz48ZmVDb2xvck1hdHJpeCBpbj0nU291cmNlQWxwaGEnIHR5cGU9J21hdHJpeCcgdmFsdWVzPScwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxMjcgMCcgcmVzdWx0PSdoYXJkQWxwaGEnLz48ZmVPZmZzZXQvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzUwJy8+PGZlQ29tcG9zaXRlIGluMj0naGFyZEFscGhhJyBvcGVyYXRvcj0nYXJpdGhtZXRpYycgazI9Jy0xJyBrMz0nMScvPjxmZUNvbG9yTWF0cml4IHR5cGU9J21hdHJpeCcgdmFsdWVzPScwIDAgMCAwIDAuODAwNTUzIDAgMCAwIDAgMC44NDQ0MzIgMCAwIDAgMCAxIDAgMCAwIDAuMTUgMCcvPjxmZUJsZW5kIG1vZGU9J25vcm1hbCcgaW4yPSdzaGFwZScgcmVzdWx0PSdlZmZlY3Q0X2lubmVyU2hhZG93XzE4OV8yNicvPjwvZmlsdGVyPjxmaWx0ZXIgaWQ9J2ZpbHRlcjJfZl8xODlfMjYnIHg9Jy0xMDQzJyB5PSctNTg4JyB3aWR0aD0nMjgzMycgaGVpZ2h0PScxOTMwJyBmaWx0ZXJVbml0cz0ndXNlclNwYWNlT25Vc2UnIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQic+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0nMCcgcmVzdWx0PSdCYWNrZ3JvdW5kSW1hZ2VGaXgnLz48ZmVCbGVuZCBtb2RlPSdub3JtYWwnIGluPSdTb3VyY2VHcmFwaGljJyBpbjI9J0JhY2tncm91bmRJbWFnZUZpeCcgcmVzdWx0PSdzaGFwZScvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzI1MCcgcmVzdWx0PSdlZmZlY3QxX2ZvcmVncm91bmRCbHVyXzE4OV8yNicvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0ncGFpbnQwX2xpbmVhcl8xODlfMjYnIHgxPSc4NjguMjM1JyB5MT0nMCcgeDI9Jzg2OC4yMzUnIHkyPScxMDI0JyBncmFkaWVudFVuaXRzPSd1c2VyU3BhY2VPblVzZSc+PHN0b3Agc3RvcC1jb2xvcj0nIzJFMzM1QScgc3RvcC1vcGFjaXR5PScwJy8+PHN0b3Agb2Zmc2V0PScxJyBzdG9wLWNvbG9yPScjMUMxQjMzJyBzdG9wLW9wYWNpdHk9JzAuMycvPjwvbGluZWFyR3JhZGllbnQ+PHJhZGlhbEdyYWRpZW50IGlkPSdwYWludDFfcmFkaWFsXzE4OV8yNicgY3g9JzAnIGN5PScwJyByPScxJyBncmFkaWVudFRyYW5zZm9ybT0nbWF0cml4KDIuNDU3MjEgMTU1Ni4wMiAtMjcwMC4yNCAyMC4wODYxIDcyMCAtMTU4LjY5KScgZ3JhZGllbnRVbml0cz0ndXNlclNwYWNlT25Vc2UnPjxzdG9wIHN0b3AtY29sb3I9JyM0Q0FDREInLz48c3RvcCBvZmZzZXQ9JzAuOTk1ODcxJyBzdG9wLWNvbG9yPSd3aGl0ZScgc3RvcC1vcGFjaXR5PScwJy8+PC9yYWRpYWxHcmFkaWVudD48Y2xpcFBhdGggaWQ9J2NsaXAwXzE4OV8yNic+PHJlY3Qgd2lkdGg9JzE0NDAnIGhlaWdodD0nMTAyNCcgZmlsbD0nd2hpdGUnLz48L2NsaXBQYXRoPjwvZGVmcz48L3N2Zz4=');
            /* background-color: #fff; */
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Enhanced Animated Background with Floating Elements */


        @keyframes backgroundShift {

            0%,
            100% {
                opacity: 0.4;
                transform: rotate(0deg) scale(1);
            }

            33% {
                opacity: 0.6;
                transform: rotate(120deg) scale(1.05);
            }

            66% {
                opacity: 0.3;
                transform: rotate(240deg) scale(0.95);
            }
        }

        .square-card {
            max-width: 28vw !important;
            min-width: 28vw !important;
            height: 120px !important;
            min-height: 120px !important;
            max-height: 120px !important;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            background: #fff;
            border-radius: 16px;
            box-shadow: 0 2px 12px rgba(60, 60, 100, 0.10);
            border: 2px solid transparent;
            transition: box-shadow 0.2s, border 0.2s;
            margin: 10px 8px 10px 0;
            word-break: break-word;
        }

        .square-card.selected {
            border: 2px solid #4ECDC4;
            box-shadow: 0 4px 18px rgba(76, 205, 196, 0.18);
        }

        .option-info-card {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 0;
            width: 100%;
            text-align: center;
            padding: 0;
        }

        .option-name.option-list-card {
            padding: 0;
            margin: 0 0 6px 0;
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-weight: 600;
            font-size: 1.08em;
            color: #2d2d2d;
            word-break: break-word;
            align-items: flex-start;
            width: 100%;
        }

        .option-name.option-list-card {
            list-style-type: none;
        }

        .option-list-card .option-list-item:first-child {
  font-weight: bold;
  text-decoration: underline;
}


        .option-list-item {
            /* background: #f6f8fa; */
            border-radius: 7px;
            padding: 3px 10px;
            margin: 2px 0;
            font-size: 0.98em;
            color: #3a3a3a;
            word-break: break-word;
            white-space: nowrap;
            text-align: left;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 26vw;
            display: block;
        }

        .option-name.option-single-card {
            font-weight: 600;
            font-size: 1.08em;
            color: #2d2d2d;
            margin-bottom: 6px;
            word-break: break-word;
            text-align: center;
        }

        .option-subtitle-card {
            font-size: 0.97em;
            color: #6a6a7a;
            margin-top: 2px;
            word-break: break-word;
            white-space: pre-line;
            text-align: center;
        }

        /* Floating particles effect */
        .floating-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0.1;
        }

        .particle {
            position: absolute;
            background: var(--glass-light);
            border-radius: 50%;
            animation: float 8s ease-in-out infinite;
        }

        .particle:nth-child(1) {
            width: 6px;
            height: 6px;
            left: 10%;
            top: 20%;
            animation-delay: -2s;
            background: rgba(102, 126, 234, 0.3);
        }

        .particle:nth-child(2) {
            width: 8px;
            height: 8px;
            left: 80%;
            top: 60%;
            animation-delay: -4s;
            background: rgba(79, 172, 254, 0.3);
        }

        .particle:nth-child(3) {
            width: 4px;
            height: 4px;
            left: 60%;
            top: 80%;
            animation-delay: -6s;
            background: rgba(56, 239, 125, 0.3);
        }

        .particle:nth-child(4) {
            width: 10px;
            height: 10px;
            left: 30%;
            top: 70%;
            animation-delay: -1s;
            background: rgba(247, 183, 51, 0.3);
        }

        .particle:nth-child(5) {
            width: 5px;
            height: 5px;
            left: 70%;
            top: 30%;
            animation-delay: -3s;
            background: rgba(252, 70, 107, 0.3);
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0px) rotate(0deg);
                opacity: 0.1;
            }

            50% {
                transform: translateY(-20px) rotate(180deg);
                opacity: 0.3;
            }
        }

        /* Enhanced Dark theme support */
        :root[data-theme="dark"] {
            --surface-primary: rgba(15, 23, 42, 0.95);
            --surface-secondary: rgba(11, 18, 32, 0.9);
            --surface-accent: rgba(102, 126, 234, 0.08);
            --text-primary: #e5e7eb;
            --text-secondary: #94a3b8;
            --text-accent: #818cf8;
        }

        :root[data-theme="dark"] body,
        /* :root[data-theme="dark"] .chat-bot-container {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e5e7eb;
        } */

        :root[data-theme="dark"] body::before {
            background:
                radial-gradient(circle at 20% 80%, rgba(102, 126, 234, 0.2) 0%, transparent 60%),
                radial-gradient(circle at 80% 20%, rgba(79, 172, 254, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(56, 239, 125, 0.1) 0%, transparent 70%);
        }

        :root[data-theme="dark"] .chat-header {
            background: linear-gradient(135deg, #1e293b, #0f172a);
        }

        :root[data-theme="dark"] .chat-sidebar {
            background: #0b1220;
            border-right: 1px solid #1f2937;
        }

        :root[data-theme="dark"] .saved-chats-header {
            color: #ffffff;
        }

        :root[data-theme="dark"] .chat-item {
            border-left-color: transparent;
        }

        :root[data-theme="dark"] .chat-item:hover {
            background: #0f172a;
            border-left-color: #2563eb;
        }

        :root[data-theme="dark"] .chat-item.active {
            background: linear-gradient(135deg, #0f172a, #111827);
            border-left-color: #2563eb;
        }

        :root[data-theme="dark"] .chat-item-title {
            color: #e5e7eb;
        }

        :root[data-theme="dark"] .chat-item-preview {
            color: #9ca3af;
        }

        :root[data-theme="dark"] .chat-item-time {
            color: #6b7280;
        }

        :root[data-theme="dark"] .chat-content {
            background: #0f172a;
        }

        :root[data-theme="dark"] .chat-messages {
            background: #0b1220;
        }

        :root[data-theme="dark"] .message.bot .message-content {
            background: #0f172a;
            color: #e5e7eb;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
        }

        :root[data-theme="dark"] .message.bot .message-content p {
            color: #e5e7eb;
        }

        :root[data-theme="dark"] .message-content code {
            background: #0b1220;
            color: #f59e0b;
        }

        :root[data-theme="dark"] .message-content blockquote {
            background: #0b1220;
            border-left-color: #2563eb;
            color: #cbd5e1;
        }

        :root[data-theme="dark"] .input-container {
            background: #0b1220;
            border-top: 1px solid #1f2937;
        }

        :root[data-theme="dark"] .message-input {
            background: #0f172a;
            border-color: #1f2937;
            color: #e5e7eb;
        }

        :root[data-theme="dark"] .message-input::placeholder {
            color: #748094;
        }

        :root[data-theme="dark"] .booking-details {
            background: #0f172a;
            border-color: #1f2937;
        }

        :root[data-theme="dark"] .info-item {
            background: #0b1220;
        }

        :root[data-theme="dark"] .info-label {
            color: #93a2b1;
        }

        :root[data-theme="dark"] .info-value {
            color: #e5e7eb;
        }

        :root[data-theme="dark"] .typing-indicator {
            background: #0f172a;
            color: #cbd5e1;
        }

        :root[data-theme="dark"] .chain-item {
            background: #0b1220;
            color: #d1d5db;
            border-left-color: #374151;
        }

        :root[data-theme="dark"] .chain-item.processing {
            background: linear-gradient(135deg, #1e1b16 0%, #292524 20%);
            border-left-color: #f59e0b;
        }

        :root[data-theme="dark"] .chain-item.completed {
            background: linear-gradient(135deg, #0f1b14 0%, #134e4a 20%);
            border-left-color: #10b981;
            color: #86efac;
        }

        :root[data-theme="dark"] .thinking-process {
            background: linear-gradient(135deg, #0f172a 0%, #0b1220 100%);
            border-color: #1f2937;
        }

        :root[data-theme="dark"] .thinking-header {
            color: #86efac;
        }

        :root[data-theme="dark"] .thinking-icon {
            border-color: #10b981;
        }

        :root[data-theme="dark"] .thought-step {
            background: #0f172a;
            border-left-color: #10b981;
        }

        :root[data-theme="dark"] .step-title {
            color: #86efac;
        }

        :root[data-theme="dark"] .step-result {
            color: #10b981;
        }

        /* Enhanced Header Controls */
        .theme-toggle {
            background: transparent;
            border: 1px solid rgb(0 0 0 / 22%);
            color: black;
            font-size: 13px;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: var(--radius-md);
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(20px);
            font-weight: 600;
            position: relative;
            overflow: hidden;
        }

        .theme-toggle::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .theme-toggle:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .theme-toggle:hover::before {
            left: 100%;
        }

        .theme-toggle:active {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .connection-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--danger-gradient);
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2);
            transition: all var(--transition-normal);
            cursor: help;
            position: relative;
        }

        .connection-indicator::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            background: inherit;
            opacity: 0;
            animation: pulse 2s infinite;
        }

        .connection-indicator.connected {
            background: var(--success-gradient);
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2), 0 0 20px rgba(56, 239, 125, 0.4);
        }

        .connection-indicator.connected::before {
            animation: connectedPulse 2s infinite;
        }

        .connection-indicator:hover {
            transform: scale(1.2);
            box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.3), 0 0 25px rgba(56, 239, 125, 0.6);
        }

        @keyframes pulse {
            0% {
                opacity: 0;
                transform: scale(1);
            }

            50% {
                opacity: 0.3;
                transform: scale(1.5);
            }

            100% {
                opacity: 0;
                transform: scale(2);
            }
        }

        @keyframes connectedPulse {
            0% {
                opacity: 0;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(1.3);
            }

            100% {
                opacity: 0;
                transform: scale(1.8);
            }
        }

        /* Markdown code block wrapper and copy button */
        .markdown-code-block {
            position: relative;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
        }

        .markdown-code-block pre {
            margin: 0;
        }

        .markdown-code-toolbar {
            position: absolute;
            top: 6px;
            right: 6px;
            display: flex;
            gap: 6px;
        }

        .copy-code-btn {
            border: 1px solid #e5e7eb;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(2px);
            padding: 4px 8px;
            font-size: 12px;
            border-radius: 6px;
            cursor: pointer;
        }

        .copy-code-btn:hover {
            background: white;
        }

        :root[data-theme="dark"] .markdown-code-block {
            border-color: #1f2937;
        }

        :root[data-theme="dark"] .copy-code-btn {
            background: #0f172a;
            color: #e5e7eb;
            border-color: #1f2937;
        }

        /* Enhanced Scroll to bottom button */
        .scroll-to-bottom {
            position: absolute;
            right: 28px;
            bottom: 100px;
            background: var(--primary-gradient);
            color: #fff;
            border: none;
            border-radius: var(--radius-lg);
            padding: 14px 18px;
            display: none;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            box-shadow: var(--shadow-lg);
            cursor: pointer;
            font-weight: 600;
            backdrop-filter: blur(30px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all var(--transition-normal);
            z-index: 10;
            overflow: hidden;
        }

        .scroll-to-bottom::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left var(--transition-slow);
        }

        .scroll-to-bottom:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: var(--shadow-xl);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .scroll-to-bottom:hover::before {
            left: 100%;
        }

        .scroll-to-bottom.show {
            display: inline-flex;
        }

        :root[data-theme="dark"] .scroll-to-bottom {
            background: #2563eb;
        }

        /* Chat Bot Container */
        .chat-bot-container {
            /* position: fixed;
            top: 0;
            left: 0; */
            width: 100vw;
            height: 100vh;
            background: url('data:image/svg+xml;charset=utf-8;base64,PHN2ZyB3aWR0aD0nMTQ0MCcgaGVpZ2h0PScxMDI0JyB2aWV3Qm94PScwIDAgMTQ0MCAxMDI0JyBmaWxsPSdub25lJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnPjxnIGNsaXAtcGF0aD0ndXJsKCNjbGlwMF8xODlfMjYpJz48cmVjdCB3aWR0aD0nMTQ0MCcgaGVpZ2h0PScxMDI0JyBmaWxsPScjRjVGNUY1Jy8+PGcgZmlsdGVyPSd1cmwoI2ZpbHRlcjBfZl8xODlfMjYpJz48ZWxsaXBzZSBjeD0nOTA2LjUnIGN5PSc3MzUnIHJ4PSc3MzYuNScgcnk9JzcxNScgZmlsbD0nI0U0QUVFRCcvPjwvZz48ZyBmaWx0ZXI9J3VybCgjZmlsdGVyMV9kZGRpXzE4OV8yNiknPjxyZWN0IHdpZHRoPScxNDQwJyBoZWlnaHQ9JzEwMjQnIGZpbGw9J3VybCgjcGFpbnQwX2xpbmVhcl8xODlfMjYpJyBmaWxsLW9wYWNpdHk9JzAuNScvPjxyZWN0IHdpZHRoPScxNDQwJyBoZWlnaHQ9JzEwMjQnIGZpbGw9J3VybCgjcGFpbnQxX3JhZGlhbF8xODlfMjYpJyBmaWxsLW9wYWNpdHk9JzAuMScvPjxnIGZpbHRlcj0ndXJsKCNmaWx0ZXIyX2ZfMTg5XzI2KSc+PGVsbGlwc2UgY3g9JzM3My41JyBjeT0nMzc3JyByeD0nOTE2LjUnIHJ5PSc0NjUnIGZpbGw9JyNCNUMwRkQnLz48L2c+PC9nPjwvZz48ZGVmcz48ZmlsdGVyIGlkPSdmaWx0ZXIwX2ZfMTg5XzI2JyB4PSctMzAnIHk9Jy0xODAnIHdpZHRoPScxODczJyBoZWlnaHQ9JzE4MzAnIGZpbHRlclVuaXRzPSd1c2VyU3BhY2VPblVzZScgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSdzUkdCJz48ZmVGbG9vZCBmbG9vZC1vcGFjaXR5PScwJyByZXN1bHQ9J0JhY2tncm91bmRJbWFnZUZpeCcvPjxmZUJsZW5kIG1vZGU9J25vcm1hbCcgaW49J1NvdXJjZUdyYXBoaWMnIGluMj0nQmFja2dyb3VuZEltYWdlRml4JyByZXN1bHQ9J3NoYXBlJy8+PGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0nMTAwJyByZXN1bHQ9J2VmZmVjdDFfZm9yZWdyb3VuZEJsdXJfMTg5XzI2Jy8+PC9maWx0ZXI+PGZpbHRlciBpZD0nZmlsdGVyMV9kZGRpXzE4OV8yNicgeD0nLTYwMycgeT0nLTExOCcgd2lkdGg9JzIxMDMnIGhlaWdodD0nMTIzMicgZmlsdGVyVW5pdHM9J3VzZXJTcGFjZU9uVXNlJyBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9J3NSR0InPjxmZUZsb29kIGZsb29kLW9wYWNpdHk9JzAnIHJlc3VsdD0nQmFja2dyb3VuZEltYWdlRml4Jy8+PGZlQ29sb3JNYXRyaXggaW49J1NvdXJjZUFscGhhJyB0eXBlPSdtYXRyaXgnIHZhbHVlcz0nMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAnIHJlc3VsdD0naGFyZEFscGhhJy8+PGZlT2Zmc2V0IGR5PSczMCcvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzMwJy8+PGZlQ29tcG9zaXRlIGluMj0naGFyZEFscGhhJyBvcGVyYXRvcj0nb3V0Jy8+PGZlQ29sb3JNYXRyaXggdHlwZT0nbWF0cml4JyB2YWx1ZXM9JzAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMSAwJy8+PGZlQmxlbmQgbW9kZT0nbm9ybWFsJyBpbjI9J0JhY2tncm91bmRJbWFnZUZpeCcgcmVzdWx0PSdlZmZlY3QxX2Ryb3BTaGFkb3dfMTg5XzI2Jy8+PGZlQ29sb3JNYXRyaXggaW49J1NvdXJjZUFscGhhJyB0eXBlPSdtYXRyaXgnIHZhbHVlcz0nMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMTI3IDAnIHJlc3VsdD0naGFyZEFscGhhJy8+PGZlT2Zmc2V0IGR5PScxNScvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzE1Jy8+PGZlQ29tcG9zaXRlIGluMj0naGFyZEFscGhhJyBvcGVyYXRvcj0nb3V0Jy8+PGZlQ29sb3JNYXRyaXggdHlwZT0nbWF0cml4JyB2YWx1ZXM9JzAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMDUgMCcvPjxmZUJsZW5kIG1vZGU9J25vcm1hbCcgaW4yPSdlZmZlY3QxX2Ryb3BTaGFkb3dfMTg5XzI2JyByZXN1bHQ9J2VmZmVjdDJfZHJvcFNoYWRvd18xODlfMjYnLz48ZmVDb2xvck1hdHJpeCBpbj0nU291cmNlQWxwaGEnIHR5cGU9J21hdHJpeCcgdmFsdWVzPScwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxMjcgMCcgcmVzdWx0PSdoYXJkQWxwaGEnLz48ZmVPZmZzZXQgZHk9JzUnLz48ZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSc1Jy8+PGZlQ29tcG9zaXRlIGluMj0naGFyZEFscGhhJyBvcGVyYXRvcj0nb3V0Jy8+PGZlQ29sb3JNYXRyaXggdHlwZT0nbWF0cml4JyB2YWx1ZXM9JzAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMDUgMCcvPjxmZUJsZW5kIG1vZGU9J25vcm1hbCcgaW4yPSdlZmZlY3QyX2Ryb3BTaGFkb3dfMTg5XzI2JyByZXN1bHQ9J2VmZmVjdDNfZHJvcFNoYWRvd18xODlfMjYnLz48ZmVCbGVuZCBtb2RlPSdub3JtYWwnIGluPSdTb3VyY2VHcmFwaGljJyBpbjI9J2VmZmVjdDNfZHJvcFNoYWRvd18xODlfMjYnIHJlc3VsdD0nc2hhcGUnLz48ZmVDb2xvck1hdHJpeCBpbj0nU291cmNlQWxwaGEnIHR5cGU9J21hdHJpeCcgdmFsdWVzPScwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAxMjcgMCcgcmVzdWx0PSdoYXJkQWxwaGEnLz48ZmVPZmZzZXQvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzUwJy8+PGZlQ29tcG9zaXRlIGluMj0naGFyZEFscGhhJyBvcGVyYXRvcj0nYXJpdGhtZXRpYycgazI9Jy0xJyBrMz0nMScvPjxmZUNvbG9yTWF0cml4IHR5cGU9J21hdHJpeCcgdmFsdWVzPScwIDAgMCAwIDAuODAwNTUzIDAgMCAwIDAgMC44NDQ0MzIgMCAwIDAgMCAxIDAgMCAwIDAuMTUgMCcvPjxmZUJsZW5kIG1vZGU9J25vcm1hbCcgaW4yPSdzaGFwZScgcmVzdWx0PSdlZmZlY3Q0X2lubmVyU2hhZG93XzE4OV8yNicvPjwvZmlsdGVyPjxmaWx0ZXIgaWQ9J2ZpbHRlcjJfZl8xODlfMjYnIHg9Jy0xMDQzJyB5PSctNTg4JyB3aWR0aD0nMjgzMycgaGVpZ2h0PScxOTMwJyBmaWx0ZXJVbml0cz0ndXNlclNwYWNlT25Vc2UnIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQic+PGZlRmxvb2QgZmxvb2Qtb3BhY2l0eT0nMCcgcmVzdWx0PSdCYWNrZ3JvdW5kSW1hZ2VGaXgnLz48ZmVCbGVuZCBtb2RlPSdub3JtYWwnIGluPSdTb3VyY2VHcmFwaGljJyBpbjI9J0JhY2tncm91bmRJbWFnZUZpeCcgcmVzdWx0PSdzaGFwZScvPjxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249JzI1MCcgcmVzdWx0PSdlZmZlY3QxX2ZvcmVncm91bmRCbHVyXzE4OV8yNicvPjwvZmlsdGVyPjxsaW5lYXJHcmFkaWVudCBpZD0ncGFpbnQwX2xpbmVhcl8xODlfMjYnIHgxPSc4NjguMjM1JyB5MT0nMCcgeDI9Jzg2OC4yMzUnIHkyPScxMDI0JyBncmFkaWVudFVuaXRzPSd1c2VyU3BhY2VPblVzZSc+PHN0b3Agc3RvcC1jb2xvcj0nIzJFMzM1QScgc3RvcC1vcGFjaXR5PScwJy8+PHN0b3Agb2Zmc2V0PScxJyBzdG9wLWNvbG9yPScjMUMxQjMzJyBzdG9wLW9wYWNpdHk9JzAuMycvPjwvbGluZWFyR3JhZGllbnQ+PHJhZGlhbEdyYWRpZW50IGlkPSdwYWludDFfcmFkaWFsXzE4OV8yNicgY3g9JzAnIGN5PScwJyByPScxJyBncmFkaWVudFRyYW5zZm9ybT0nbWF0cml4KDIuNDU3MjEgMTU1Ni4wMiAtMjcwMC4yNCAyMC4wODYxIDcyMCAtMTU4LjY5KScgZ3JhZGllbnRVbml0cz0ndXNlclNwYWNlT25Vc2UnPjxzdG9wIHN0b3AtY29sb3I9JyM0Q0FDREInLz48c3RvcCBvZmZzZXQ9JzAuOTk1ODcxJyBzdG9wLWNvbG9yPSd3aGl0ZScgc3RvcC1vcGFjaXR5PScwJy8+PC9yYWRpYWxHcmFkaWVudD48Y2xpcFBhdGggaWQ9J2NsaXAwXzE4OV8yNic+PHJlY3Qgd2lkdGg9JzE0NDAnIGhlaWdodD0nMTAyNCcgZmlsbD0nd2hpdGUnLz48L2NsaXBQYXRoPjwvZGVmcz48L3N2Zz4=');
            display: flex;
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            flex-direction: column;
            z-index: 1000;
            margin: 0 !important;
            padding: 0;
            border-radius: 0;
            box-shadow: none;
        }

        .chat-bot-container.active {
            /* transform: translateY(0) scale(1); */
            opacity: 1;
            display: flex;
            flex-direction: row;
        }

        .chat-header {
            background: white;
            color: #ffffff;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 2px 0 12px rgba(0, 0, 0, 0.25);

            color: black;
            padding: 15px 28px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            flex-shrink: 0;
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(20px);
            overflow: hidden;
            margin: 5px;
            border-radius: 20px;
        }

        .chat-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            pointer-events: none;
        }

        .chat-header h1 {
            font-size: 22px;
            font-weight: 800;
            display: flex;
            align-items: center;
            gap: 16px;
            letter-spacing: -0.02em;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 1;
        }

        .bot-icon {
            width: 48px;
            height: 48px;
            background: var(--glass-light);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: var(--shadow-lg);
            transition: all var(--transition-normal);
            position: relative;
            overflow: hidden;
        }

        .bot-icon::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 3s ease-in-out infinite;
        }

        .bot-icon:hover {
            transform: scale(1.05) rotate(5deg);
            box-shadow: var(--shadow-xl);
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%) translateY(-100%) rotate(45deg);
            }

            100% {
                transform: translateX(100%) translateY(100%) rotate(45deg);
            }
        }

        .chat-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .close-btn {
            /* background: var(--glass-medium); */
            border: 2px solid rgb(0 0 0 / 22%);
            color: black;
            font-size: 20px;
            cursor: pointer;
            padding: 10px;
            border-radius: 50%;
            transition: all var(--transition-normal);
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
        }

        .close-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform var(--transition-normal);
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1);
            box-shadow: var(--shadow-lg);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .close-btn:hover::before {
            transform: translateX(100%);
        }

        .close-btn:active {
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        /* Main Chat Layout */
        .chat-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            right: 2px;
            position: relative;
        }

        /* Enhanced Sidebar Styles */
        .chat-sidebar {
            gap: 10px;
            width: 250px;
            background: white;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: #fff;
            border: 3px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.35);


            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            resize: horizontal;
            overflow: auto;
            min-width: 260px;
            max-width: 50vw;
            backdrop-filter: blur(30px);
            box-shadow: var(--shadow-md);
            position: relative;
            margin: 5px;
            border-radius: 20px;
        }

        .chat-sidebar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: transparent;
            pointer-events: none;
        }

        .sidebar-header {
            padding: 15px 24px;
            border-bottom: 2px solid rgb(0 0 0 / 12%);
            display: flex;
            justify-content: center;
            background: transprent;
            position: relative;
            z-index: 1;
        }

        .sidebar-header h1 {
            color: #000;
        }

        .new-chat-btn {
            width: 100%;
            max-width: 190px;
            padding: 12px 20px;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: var(--radius-lg);
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-normal);
            display: flex;
            justify-content: center;
            gap: 10px;
            align-items: center;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .new-chat-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .new-chat-btn:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-xl);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .new-chat-btn:hover::before {
            left: 100%;
        }

        .new-chat-btn:active {
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .new-chat-btn span:first-child {
            font-size: 18px;
            font-weight: 300;
        }

        .saved-chats {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .saved-chats-header {
            padding: 18px 20px 12px;
            font-size: 12px;
            font-weight: 700;
            color: #000;
            text-transform: uppercase;
            letter-spacing: 0.8px;
        }

        /* ========== Chat Sidebar Items ========== */
        .chat-item {
            position: relative;
            padding: 14px 20px;
            margin: 6px 12px;
            cursor: pointer;
            border-radius: 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(0, 0, 0, 0.1);
            transition: all 0.25s ease;
            backdrop-filter: blur(10px) saturate(160%);
            -webkit-backdrop-filter: blur(10px) saturate(160%);
            overflow: hidden;
        }

        .chat-item::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg,
                    rgba(102, 126, 234, 0.15),
                    rgba(118, 75, 162, 0.15));
            opacity: 0;
            border: 2px solid rgba(0, 0, 0, 0.1);

            transition: opacity 0.25s ease;
            border-radius: inherit;
        }

        .chat-item:hover {
            transform: translateX(4px) scale(1.02);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
            /* border-color: rgba(102, 126, 234, 0.4); */
        }



        .chat-item.active {
            background: white;
            border: 1px solid rgba(102, 126, 234, 0.5);
            box-shadow: 0 4px 14px rgba(102, 126, 234, 0.35);
            transform: translateX(3px);
        }

        .chat-item-title {
            font-size: 14px;
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 10vw;
        }

        .chat-item-preview {
            font-size: 12px;
            color: #a1a1aa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-item-time {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
        }

        /* Delete button */
        .chat-item-delete {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(239, 68, 68, 0.8);
            color: white;
            border: none;
            border-radius: 50%;
            width: 22px;
            height: 22px;
            font-size: 12px;
            line-height: 22px;
            cursor: pointer;
            opacity: 0;
            transition: all 0.2s ease;
        }

        .chat-item:hover .chat-item-delete {
            opacity: 1;
        }

        .chat-item-delete:hover {
            background: rgba(239, 68, 68, 1);
            transform: translateY(-50%) scale(1.1);
        }


        /* Enhanced Chat Messages Area */
        .chat-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            margin: 5px;
            border-radius: 20px;
            height: 10vh;
            align-items: center;
            background: white;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 32px 28px;
            background: white;
            display: flex;
            flex-direction: column;
            gap: 24px;
            position: relative;
            border-radius: 20px 20px 0 0;
            width: 100%;
            max-width: 1440px;
        }

        .chat-messages::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 32px;
            /* background: url('C:/Users/LogeshB/Downloads/Group 2824.png'); */
            background-color: transparent;
            pointer-events: none;
            z-index: 1;
        }

        .chat-messages::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 32px;
            background: transparent;
            pointer-events: none;
            z-index: 1;
        }

        /* Message Styles */
        .message {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 15px;
            width: 100%;
        }

        .message.user {
            justify-content: flex-end;
            flex-direction: row-reverse;
        }

        .message.user .message-content {
            /* background: #d1d5db7a; */
            color: black;
            border-radius: var(--radius-xl) var(--radius-xl) var(--radius-sm) var(--radius-xl);
            max-width: 75%;
            padding: 9px 24px;
            font-size: 15px;
            line-height: 1.6;
            word-wrap: break-word;
            margin-left: auto;
            width: auto;
            /* box-shadow: -1px 4px 4px 3px #80808045; */
            backdrop-filter: blur(20px);
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .message.user .message-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #d1d5db7a;
            pointer-events: none;
        }

        .message.user .message-avatar {
            width: 42px;
            height: 42px;
            /* background: var(--primary-gradient); */
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            flex-shrink: 0;
            margin-top: 2px;
            margin-left: 16px;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .message.bot .message-avatar-response {
            width: 42px;
            height: 42px;
            /* background: var(--primary-gradient); */
            border-radius: var(--radius-lg);
            display: flex;
            background: white;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            flex-shrink: 0;
            margin-top: 2px;
            margin-left: 16px;
            /* box-shadow: var(--shadow-lg); */
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: hidden;
        }

        .message.user .message-avatar::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: avatarShimmer 2s linear infinite;
        }

        .message.user .message-avatar-response::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: white;
            animation: avatarShimmer 2s linear infinite;
        }

        @keyframes avatarShimmer {
            0% {
                transform: translateX(-100%) translateY(-100%) rotate(45deg);
            }

            100% {
                transform: translateX(100%) translateY(100%) rotate(45deg);
            }
        }

        .message.bot {
            justify-content: flex-start;
            flex-direction: row;
            margin-top: 10px;
        }

        .message.bot .message-content {
            /* background: linear-gradient(
            135deg,
            rgba(255, 255, 255, 0.15) 0%,
            rgba(255, 255, 255, 0.05) 100%
        ),
        radial-gradient(
            circle at top left,
            rgba(173, 216, 255, 0.25),
            transparent 70%
        ); */
            background: white;
            /* background-blend-mode: overlay; */
            color: #1e293b;
            border-radius: 22px 22px 22px 8px;
            width: 65%;
            max-width: 70vw;
            box-shadow:
                -1px 1px 4px 3px #80808054;
            padding: 20px 24px;
            font-size: 15px;
            line-height: 1.7;
            word-wrap: break-word;
            border: 1px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease-in-out;
        }

        /* Animated accent bar */
        .message.bot .message-content::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 5px;
            height: 100%;
            /* background: linear-gradient(180deg, #60a5fa, #818cf8, #c084fc); */
            border-radius: 0 3px 3px 0;
            animation: gradient-flow 5s ease-in-out infinite;
            background-size: 200% 200%;
        }

        /* Gradient animation */
        @keyframes gradient-flow {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        /* Hover effect for interactivity */
        .message.bot .message-content:hover {
            transform: translateY(-2px);
            box-shadow:
                0 8px 25px rgba(0, 0, 0, 0.08),
                inset 0 0 30px rgba(255, 255, 255, 0.12);
        }

        /* When unified panel is used (preserve your logic) */
        .message.bot .message-content:has(.unified-cot-response-panel) {
            background: none;
            box-shadow: none;
            padding: 20px 24px;
            border: none;
            backdrop-filter: none;
            box-shadow: -1px 1px 4px 3px #80808054;
        }

        .message.bot .message-content:has(.unified-cot-response-panel)::before {
            display: none;
        }

        .message.bot .message-avatar {
            width: 42px;
            height: 42px;
            background: var(--secondary-gradient);
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            flex-shrink: 0;
            margin-top: 2px;
            margin-right: 16px;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        /* .message.bot .message-avatar::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            animation: avatarShimmer 3s linear infinite;
        } */

        /* Enhanced Success Box Styling */
        .booking-confirmation {
            background: linear-gradient(135deg, var(--surface-primary), rgba(56, 239, 125, 0.03));
            border-radius: var(--radius-xl);
            padding: 32px;
            text-align: center;
            border: 2px solid rgba(56, 239, 125, 0.2);
            margin: 20px 0;
            box-shadow: var(--shadow-lg);
            backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
        }

        .booking-confirmation::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--success-gradient);
            border-radius: 2px 2px 0 0;
        }

        .success-icon {
            width: 72px;
            height: 72px;
            background: var(--success-gradient);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
            color: white;
            font-size: 32px;
            box-shadow: var(--shadow-lg), 0 0 30px rgba(56, 239, 125, 0.4);
            animation: successPulse 2s ease-in-out;
            border: 3px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }

        .success-icon::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            background: var(--success-gradient);
            opacity: 0.3;
            animation: successRipple 2s ease-out infinite;
        }

        @keyframes successPulse {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes successRipple {
            0% {
                transform: scale(1);
                opacity: 0.3;
            }

            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        .confirmation-message {
            font-size: 16px;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 20px;
        }

        /* Enhanced Cards Section */
        .cards-section {
            display: flex;
            flex-direction: row;
            gap: 20px;
            background: transparent;
            border-radius: 12px;
            padding: 15px;
            margin-top: 10px;
        }

        .section-title {
            font-size: 15px;
            font-weight: 600;
            color: #2196F3;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Enhanced Universal Option Card Styling */
        .option-card {
            background: var(--surface-primary);
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 18px;
            /* width: 50%; */
            cursor: pointer;
            transition: all var(--transition-normal);
            border: 2px solid rgba(148, 163, 184, 0.1);
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(20px);
        }

        .option-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--primary-gradient);
            transform: scaleX(0);
            transition: transform var(--transition-normal);
            border-radius: 2px 2px 0 0;
        }

        .option-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.03) 0%, transparent 60%);
            opacity: 0;
            transition: opacity var(--transition-normal);
            pointer-events: none;
        }

        .option-card:hover {
            background: var(--surface-secondary);
            transform: translateY(-4px) scale(1.02);
            box-shadow: var(--shadow-lg);
            border-color: rgba(102, 126, 234, 0.2);
        }

        .option-card:hover::before {
            transform: scaleX(1);
        }

        .option-card:hover::after {
            opacity: 1;
        }

        .option-card.selected {
            border-color: var(--primary-500);
            background: linear-gradient(135deg, var(--primary-50) 0%, var(--primary-100) 100%);
            transform: translateY(-2px) scale(1.01);
            box-shadow: var(--shadow-xl);
        }

        .option-card.selected::before {
            transform: scaleX(1);
            background: var(--secondary-gradient);
        }

        .option-card.selected::after {
            opacity: 0.8;
            background: linear-gradient(135deg, rgba(79, 172, 254, 0.08) 0%, rgba(0, 242, 254, 0.05) 100%);
        }

        .avatar {
            width: 56px;
            height: 56px;
            border-radius: var(--radius-lg);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-md);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-weight: 700;
            font-size: 20px;
            flex-shrink: 0;
            position: relative;
            overflow: hidden;
            transition: all var(--transition-normal);
        }

        .avatar::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: transform var(--transition-slow);
        }

        .option-card:hover .avatar::before {
            animation: shimmer 1s ease-in-out;
        }

        .option-card:hover .avatar {
            transform: scale(1.1) rotate(5deg);
            box-shadow: var(--shadow-lg);
        }

        .option-info {
            flex: 1;
            /* max-width: fit-content; */
            width: 100%;
        }

        .option-name {
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 4px;
            font-size: 14px;
            line-height: 1.3;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-direction: column;
        }

        .option-subtitle {
            font-size: 12px;
            color: #666;
            line-height: 1.3;
            opacity: 0.9;
        }

        /* ==================== Employee Card Styles ==================== */
        .employee-card {
            background: var(--surface-elevated);
            border-radius: 20px;
            padding: 24px;
            margin: 8px 0;
            border: 2px solid transparent;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow-lg);
            min-width: 320px;
            max-width: 400px;
        }

        .employee-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--primary-gradient);
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 0;
        }

        .employee-card:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: var(--primary-400);
            box-shadow: var(--shadow-xl), 0 0 30px rgba(102, 126, 234, 0.15);
        }

        .employee-card:hover::before {
            opacity: 0.03;
        }

        .employee-card.selected {
            border-color: var(--primary-500);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(56, 189, 248, 0.05));
            transform: translateY(-4px) scale(1.02);
            box-shadow: var(--shadow-xl), 0 0 30px rgba(102, 126, 234, 0.2);
        }

        .employee-card.selected::before {
            opacity: 0.05;
        }

        .employee-card>* {
            position: relative;
            z-index: 1;
        }

        .employee-treatment-team {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.05));
            border-radius: 12px;
            padding: 10px 14px;
            margin-bottom: 16px;
            border-left: 4px solid var(--primary-500);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .employee-treatment-team-icon {
            font-size: 16px;
            opacity: 0.8;
        }

        .employee-treatment-team-text {
            font-size: 13px;
            font-weight: 600;
            color: var(--primary-700);
        }

        .employee-treatment-team-member-badge {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.12), rgba(5, 150, 105, 0.08));
            border-radius: 12px;
            padding: 10px 14px;
            margin-bottom: 16px;
            border-left: 4px solid #10b981;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .employee-treatment-team-member-icon {
            font-size: 16px;
            opacity: 0.8;
        }

        .employee-treatment-team-member-text {
            font-size: 13px;
            font-weight: 600;
            color: #059669;
        }

        .employee-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 18px;
        }

        .employee-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--primary-gradient);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            font-weight: 600;
            box-shadow: var(--shadow-md);
            position: relative;
            overflow: hidden;
        }

        .employee-avatar::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transform: rotate(45deg);
            transition: transform 0.6s ease;
        }

        .employee-card:hover .employee-avatar::before {
            transform: rotate(45deg) translate(200%, 200%);
        }

        .employee-main-info {
            flex: 1;
        }

        .employee-name {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 4px;
            line-height: 1.2;
        }

        .employee-match-score {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: linear-gradient(135deg, var(--success-500), var(--success-600));
            color: rgb(3, 3, 3);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            box-shadow: var(--shadow-sm);
        }

        .employee-match-score.low-match {
            background: linear-gradient(135deg, var(--warning-500), var(--warning-600));
        }

        .employee-match-score.no-match {
            background: linear-gradient(135deg, var(--error-500), var(--error-600));
        }

        .employee-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }

        .employee-detail-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(var(--primary-500-rgb), 0.05);
            border-radius: 10px;
            border-left: 3px solid var(--primary-500);
        }

        .employee-detail-icon {
            font-size: 14px;
            opacity: 0.8;
        }

        .employee-detail-text {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .employee-languages {
            margin-top: 12px;
        }

        .employee-languages-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .employee-language-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .employee-language-tag {
            background: linear-gradient(135deg, var(--accent-500), var(--accent-600));
            color: rgb(0, 0, 0);
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 11px;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
        }

        .employee-auth-info {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05));
            border-radius: 12px;
            padding: 12px;
            margin-top: 16px;
            border-left: 4px solid var(--success-500);
        }

        .employee-auth-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--success-700);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .employee-auth-name {
            font-size: 13px;
            color: var(--success-600);
            font-weight: 500;
        }

        .employee-treatment-info {
            background: linear-gradient(135deg, rgba(147, 51, 234, 0.1), rgba(126, 34, 206, 0.05));
            border-radius: 12px;
            padding: 12px;
            margin-top: 12px;
            border-left: 4px solid var(--purple-500);
        }

        .employee-treatment-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--purple-700);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .employee-treatment-name {
            font-size: 13px;
            color: var(--purple-600);
            font-weight: 500;
        }

        /* ==================== Employee Cards Section ==================== */
        .employee-cards-section {
            display: flex;
            flex-direction: row;
            gap: 16px;
            max-height: 60vh;
            overflow-y: auto;
            padding: 8px;
        }

        .employee-cards-section::-webkit-scrollbar {
            /* width: 8px; */
        }

        .employee-cards-section::-webkit-scrollbar-track {
            background: rgba(var(--primary-500-rgb), 0.1);
            border-radius: 4px;
        }

        .employee-cards-section::-webkit-scrollbar-thumb {
            background: var(--primary-500);
            border-radius: 4px;
        }

        .employee-cards-section::-webkit-scrollbar-thumb:hover {
            background: var(--primary-600);
        }

        /* Responsive adjustments for employee cards */
        @media (max-width: 768px) {
            .employee-card {
                min-width: unset;
                max-width: 100%;
                margin: 6px 0;
                padding: 20px;
            }

            .employee-details {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .employee-avatar {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }

            .employee-name {
                font-size: 16px;
            }
        }

        /* Confirmation Dialog */
        .confirmation-dialog {
            background: linear-gradient(135deg, #f8f9fa, #ffffff);
            border-radius: 15px;
            padding: 20px;
            margin-top: 10px;
            border: 1px solid #e9ecef;
        }

        .confirmation-title {
            font-size: 16px;
            font-weight: 600;
            color: #1a1a1a;
            margin-bottom: 15px;
            text-align: center;
        }

        .confirmation-options {
            display: flex;
            gap: 12px;
            margin-bottom: 15px;
        }

        .confirm-btn {
            flex: 1;
            padding: 16px 20px;
            border: none;
            border-radius: var(--radius-lg);
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all var(--transition-normal);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .confirm-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left var(--transition-slow);
        }

        .confirm-btn:hover::before {
            left: 100%;
        }

        .confirm-btn.yes {
            background: var(--success-gradient);
            color: white;
            box-shadow: var(--shadow-md);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .confirm-btn.yes:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--shadow-lg), 0 0 25px rgba(56, 239, 125, 0.4);
        }

        .confirm-btn.no {
            background: var(--danger-gradient);
            color: white;
            box-shadow: var(--shadow-md);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .confirm-btn.no:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: var(--shadow-lg), 0 0 25px rgba(252, 70, 107, 0.4);
        }

        .confirm-btn:active {
            transform: translateY(-1px) scale(1.01);
            box-shadow: var(--shadow-sm);
        }

        /* Enhanced Booking Details */
        .booking-details {
            background: var(--surface-primary);
            border-radius: var(--radius-lg);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(148, 163, 184, 0.1);
            backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
        }

        .booking-details::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--info-gradient);
            border-radius: 2px 2px 0 0;
        }

        .booking-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid #f0f0f0;
        }

        .confirmed-badge {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .booking-info {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            background: var(--surface-secondary);
            border-radius: var(--radius-md);
            transition: all var(--transition-normal);
            border: 1px solid rgba(148, 163, 184, 0.08);
            position: relative;
            overflow: hidden;
        }

        .info-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background: var(--primary-gradient);
            transform: scaleY(0);
            transition: transform var(--transition-normal);
        }

        .info-item:hover {
            background: rgba(102, 126, 234, 0.05);
            transform: translateX(4px);
            box-shadow: var(--shadow-sm);
            border-color: rgba(102, 126, 234, 0.2);
        }

        .info-item:hover::before {
            transform: scaleY(1);
        }

        .info-label {
            font-weight: 600;
            color: #495057;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 90px;
        }

        .info-value {
            color: #1a1a1a;
            font-size: 13px;
            font-weight: 500;
            text-align: right;
        }

        /* Enhanced Input Container */
        .input-container {
            padding: 24px 28px;
            background: white;
            /* border-top: 1px solid rgba(148, 163, 184, 0.12); */
            display: flex;
            align-items: center;
            gap: 16px;
            flex-shrink: 0;
            /* box-shadow: var(--shadow-lg); */
            backdrop-filter: blur(30px);
            position: relative;
            border-radius: 0 0 20px 20px;
            width: 100%;
            max-width: 1440px;
        }

        .input-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: white;
        }

        .message-input {
            flex: 1;
            padding: 16px 24px;
            border: 2px solid rgba(148, 163, 184, 0.15);
            border-radius: 8px;
            font-size: 15px;
            outline: none;
            background: var(--surface-secondary);
            transition: all var(--transition-normal);
            resize: none;
            font-family: inherit;
            box-shadow: var(--shadow-sm);
            backdrop-filter: blur(20px);
            font-weight: 500;
            position: relative;
            scroll-behavior: smooth;
            scrollbar-width: thin;
        }

        .message-input:focus {
            border-color: var(--primary-500);
            background: white;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.12), var(--shadow-lg);
            transform: translateY(-2px);
        }

        .message-input::placeholder {
            color: var(--text-secondary);
            font-weight: 400;
        }

        .send-btn {
            width: 52px;
            height: 52px;
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: var(--radius-lg);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all var(--transition-normal);
            flex-shrink: 0;
            box-shadow: var(--shadow-lg);
            border: 2px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
        }

        .send-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transform: translateX(-100%);
            transition: transform var(--transition-normal);
        }

        .send-btn:hover {
            transform: scale(1.1) translateY(-2px);
            box-shadow: var(--shadow-xl);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .send-btn:hover::before {
            transform: translateX(100%);
        }

        .send-btn:active {
            transform: scale(1.05) translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .send-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .send-btn:disabled:hover {
            transform: none;
            box-shadow: var(--shadow-md);
        }

        /* Enhanced Typing Indicator */
        .typing-indicator {
            display: none;
            flex-direction: column;
            gap: 12px;
            color: var(--text-secondary);
            font-size: 14px;
            padding: 20px 24px;
            background: linear-gradient(135deg, rgba(56, 239, 125, 0.08) 0%, rgba(17, 153, 142, 0.06) 100%);
            border: 2px solid rgba(56, 239, 125, 0.2);
            border-radius: var(--radius-xl) var(--radius-xl) var(--radius-xl) var(--radius-sm);
            box-shadow: var(--shadow-lg);
            animation: typingPulse 2s ease-in-out infinite;
            backdrop-filter: blur(20px);
            position: relative;
            overflow: hidden;
            min-width: 700px;
            max-width: min(90vw, 700px);
        }

        .typing-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .typing-main-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .typing-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(56, 239, 125, 0.1), transparent);
            animation: typingShimmer 2s linear infinite;
        }

        @keyframes typingPulse {

            0%,
            100% {
                border-color: rgba(56, 239, 125, 0.2);
                box-shadow: var(--shadow-md);
            }

            50% {
                border-color: rgba(56, 239, 125, 0.4);
                box-shadow: var(--shadow-lg), 0 0 20px rgba(56, 239, 125, 0.2);
            }
        }

        @keyframes typingShimmer {
            0% {
                left: -100%;
            }

            100% {
                left: 100%;
            }
        }

        /* Enhanced Chain of Thoughts Styling */
        .thinking-process {
            margin-top: 20px;
            padding: 24px;
            background: linear-gradient(135deg, rgba(56, 239, 125, 0.05) 0%, rgba(17, 153, 142, 0.03) 100%);
            border-radius: var(--radius-lg);
            border: 2px solid rgba(56, 239, 125, 0.15);
            backdrop-filter: blur(20px);
            box-shadow: var(--shadow-md);
            position: relative;
            overflow: hidden;
        }

        .thinking-process::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--success-gradient);
            border-radius: 2px 2px 0 0;
        }

        .thinking-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
            color: #065f46;
            font-weight: 600;
            font-size: 14px;
        }

        .thinking-icon {
            width: 20px;
            height: 20px;
            border: 2px solid #10b981;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .thought-steps {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .thought-step {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border-left: 3px solid #10b981;
            animation: thoughtReveal 0.5s ease forwards;
            opacity: 0;
        }

        @keyframes thoughtReveal {
            to {
                opacity: 1;
            }
        }

        .thought-step:nth-child(1) {
            animation-delay: 0.1s;
        }

        .thought-step:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thought-step:nth-child(3) {
            animation-delay: 0.3s;
        }

        .thought-step:nth-child(4) {
            animation-delay: 0.4s;
        }

        .thought-step:nth-child(5) {
            animation-delay: 0.5s;
        }

        .thought-step:nth-child(6) {
            animation-delay: 0.6s;
        }

        .thought-step:nth-child(7) {
            animation-delay: 0.7s;
        }

        .step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            flex-shrink: 0;
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            color: #065f46;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .step-result {
            color: #10b981;
            font-size: 13px;
            font-weight: 600;
        }

        /* Enhanced Container for live chain-of-thought messages */
        .chain-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-left: 0;
            margin-top: 12px;
            overflow-y: auto;
            width: 100%;
            padding: 0;
            position: relative;
            background: white;
        }

        /* Progress bar for COT */
        .cot-progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 16px;
            position: relative;
        }

        .cot-progress-fill {
            height: 100%;
            background: var(--primary-gradient);
            border-radius: 2px;
            transition: width 0.5s ease;
            position: relative;
            overflow: hidden;
        }

        .cot-progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressShimmer 2s linear infinite;
        }

        @keyframes progressShimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        /* ===== Dropdown / Expandable Style Enhancement ===== */

        .chain-item {
            width: 90%;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--surface-primary);
            font-size: 14px;
            padding: 18px 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            line-height: 1.6;
            word-break: break-word;
            opacity: 1;
            display: flex;
            align-items: flex-start;
            gap: 18px;
            border-left: 4px solid #e2e8f0;
            position: relative;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(148, 163, 184, 0.08);
            font-weight: 500;
            min-height: 60px;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .chain-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        /* clickable header and expandable details */
        .chain-item .chain-text {
            flex: 1;
            min-width: 0;
            line-height: 1.6;
            font-weight: 500;
            position: relative;
        }

        .chain-item .chain-toggle {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%) rotate(0deg);
            transition: transform 0.3s ease;
            font-size: 14px;
            opacity: 0.6;
        }

        .chain-item.expanded .chain-toggle {
            transform: translateY(-50%) rotate(90deg);
            opacity: 1;
        }

        /* expandable details section */
        .chain-item .chain-details {
            max-height: 0;
            overflow: hidden;
            transition: all 0.4s ease;
            opacity: 0;
            margin-top: 0;
            font-size: 13px;
            color: #64748b;
        }

        .chain-item.expanded .chain-details {
            max-height: 300px;
            opacity: 1;
            margin-top: 10px;
        }

        /* existing animation and state styles remain same */
        .chain-item.processing {
            border-left-color: var(--primary-500);
            background: linear-gradient(135deg, var(--primary-50) 0%, rgba(102, 126, 234, 0.08) 100%);
            color: var(--primary-700);
            /* box-shadow: var(--shadow-lg), 0 0 20px rgba(102, 126, 234, 0.1); */
        }

        .chain-item.completed {
            border-left-color: #10b981;
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.05) 0%, rgba(56, 239, 125, 0.08) 100%);
            /* box-shadow: var(--shadow-lg), 0 0 20px rgba(16, 185, 129, 0.1); */
        }

        .chain-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            /* background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent); */
        }

        .chain-loader {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(102, 126, 234, 0.2);
            border-top-color: var(--primary-500);
            border-radius: 50%;
            animation: chainSpin 1s linear infinite;
            flex-shrink: 0;
            position: relative;
            margin-top: 2px;
        }

        .chain-loader::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border-radius: 50%;
            background: radial-gradient(circle, var(--primary-500) 30%, transparent 70%);
            animation: chainPulse 2s ease-in-out infinite;
        }

        .chain-check {
            width: 24px;
            height: 24px;
            background: var(--success-gradient);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white !important;
            font-size: 12px;
            font-weight: bold;
            flex-shrink: 0;
            box-shadow: var(--shadow-sm), 0 0 15px rgba(16, 185, 129, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            margin-top: 2px;
            animation: checkScale 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes checkScale {
            0% {
                transform: scale(0);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes chainPulse {

            0%,
            100% {
                opacity: 0.3;
            }

            50% {
                opacity: 0.8;
            }
        }

        @keyframes chainSpin {
            to {
                transform: rotate(360deg);
            }
        }

        .chain-text {
            flex: 1;
            min-width: 0;
            line-height: 1.6;
            font-weight: 500;
        }



        .chain-timestamp {
            font-size: 11px;
            color: var(--text-secondary);
            opacity: 0.7;
            margin-top: 4px;
            font-weight: 400;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.4;
            }
        }

        .chain-item {
            opacity: 0;
            transform: translateY(10px);
            animation: fadeIn 0.3s ease forwards;
            /* margin: 8px 0; */
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chain-text::after {
            content: '|';
            animation: blink 1s infinite;
            margin-left: 2px;
            color: #4f46e5;
        }

        .chain-item:last-child .chain-text::after {
            content: '';
            animation: none;
        }

        .chain-loader {
            width: 16px;
            height: 16px;
            border: 2px solid #e2e8f0;
            border-top-color: #4f46e5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .chain-check {
            width: 16px;
            height: 16px;
            background: #10b981;
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            flex-shrink: 0;
            font-size: 10px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .chain-text {
            flex: 1;
            font-size: 14px;
            line-height: 1.5;
            color: #334155;
            min-height: 1em;
            /* Ensure consistent height during typing */
        }

        .unified-cot-response-panel {
            display: none;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            /* margin: 12px 0; */
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .unified-panel-header {
            padding: 12px 16px;
            background: #f8fafc;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #e2e8f0;
            transition: background-color 0.2s ease;
        }

        .unified-panel-header:hover {
            background: #f1f5f9;
        }

        .unified-panel-header-text {
            font-weight: 600;
            color: #4f46e5;
            font-size: 14px;
        }

        .unified-panel-toggle {
            background: none;
            border: none;
            font-size: 12px;
            color: #64748b;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .unified-panel-toggle:hover {
            background: #e2e8f0;
            color: #4f46e5;
        }

        .unified-cot-response-panel .chain-container {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease;
            padding: 0 16px;
        }

        .unified-cot-response-panel.collapsed .chain-container {
            max-height: 0;
            padding: 0;
        }

        /* Dark mode support */
        :root[data-theme="dark"] .unified-cot-response-panel {
            background: #1e293b;
            border: 1px solid #334155;
        }

        :root[data-theme="dark"] .unified-panel-header {
            background: #0f172a;
            border-bottom-color: #334155;
        }

        :root[data-theme="dark"] .unified-panel-header:hover {
            background: #1e293b;
        }

        :root[data-theme="dark"] .unified-panel-header-text {
            color: #818cf8;
        }

        /* Chain item styles */
        .chain-item {
            display: flex;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #e2e8f0;
        }

        .chain-item:last-child {
            border-bottom: none;
        }

        .chain-loader,
        .chain-check {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .chain-loader {
            border: 2px solid #e2e8f0;
            border-top-color: #4f46e5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .chain-check {
            color: #10b981;
            font-weight: bold;
        }

        .chain-text {
            flex: 1;
            font-size: 14px;
            line-height: 1.5;
            color: #334155;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Dark mode adjustments */
        :root[data-theme="dark"] .chain-item {
            border-bottom-color: #334155;
        }

        :root[data-theme="dark"] .chain-text {
            color: #e2e8f0;
        }

        :root[data-theme="dark"] .chain-loader {
            border-color: #334155;
            border-top-color: #818cf8;
        }

        /* .unified-cot-response-panel .chain-item.completed::before {
            background: linear-gradient(90deg, transparent, rgba(16, 185, 129, 0.4), transparent);
        } */

        /* .cot-response-separator {
            display: flex;
            align-items: center;
            padding: 16px 20px;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            border-top: 1px solid rgba(148, 163, 184, 0.1);
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        } */

        /* .separator-line {
            flex: 1;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.3), transparent);
        } */

        .separator-label {
            margin: 0 16px;
            font-size: 12px;
            font-weight: 600;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            display: none;
            align-items: center;
            gap: 6px;
        }

        .separator-label::before {
            content: 'HA';
            font-size: 14px;
        }

        .bot-response-content {
            padding: 20px;
            background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
            color: #1e293b;
            font-size: 15px;
            line-height: 1.6;
        }

        .bot-response-content h1,
        .bot-response-content h2,
        .bot-response-content h3,
        .bot-response-content h4,
        .bot-response-content h5,
        .bot-response-content h6 {
            color: #1e293b;
            margin-top: 0;
            margin-bottom: 12px;
        }

        .bot-response-content p {
            margin-bottom: 12px;
        }

        .bot-response-content ul,
        .bot-response-content ol {
            margin-bottom: 12px;
            padding-left: 20px;
        }

        .bot-response-content code {
            background: rgba(102, 126, 234, 0.1);
            color: #667eea;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .bot-response-content blockquote {
            border-left: 4px solid #667eea;
            background: rgba(102, 126, 234, 0.05);
            margin: 16px 0;
            padding: 12px 16px;
            border-radius: 8px;
        }

        .typing-indicator span {
            transition: opacity 0.3s ease;
            margin-right: 2px;
        }

        .typing-dots {
            display: inline-flex;
            gap: 1px;
        }

        .typing-dot {
            font-size: 16px;
            color: #2196F3;
            animation: slowBlink 2s infinite;
            line-height: 1;
        }

        .typing-dot:nth-child(1) {
            animation-delay: 0s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.3s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.6s;
        }

        @keyframes textBlink {

            0%,
            70% {
                opacity: 1;
            }

            85% {
                opacity: 0.4;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes slowBlink {

            0%,
            50% {
                opacity: 0.3;
            }

            25% {
                opacity: 1;
            }

            75%,
            100% {
                opacity: 0.3;
            }
        }

        /* Scrollable cards */
        .cards-section.scrollable-row {
            display: flex;
            overflow-x: auto;
            gap: 15px;
            padding-bottom: 10px;
            scroll-snap-type: x mandatory;
            -webkit-overflow-scrolling: touch;
        }

        .cards-section.scrollable-row .option-card {
            flex: 0 0 auto;
            width: fit-content;
            scroll-snap-align: start;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            width: 28vw;
            max-width: 28vw;
            min-width: 28vw;
        }

        .option-name,
        .option-subtitle {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Enhanced Custom Scrollbar */
        .chat-messages::-webkit-scrollbar,
        .saved-chats::-webkit-scrollbar {
            width: 8px;
        }

        .chat-messages::-webkit-scrollbar-track,
        .saved-chats::-webkit-scrollbar-track {
            background: rgba(148, 163, 184, 0.1);
            border-radius: 4px;
            margin: 4px;
        }

        .chat-messages::-webkit-scrollbar-thumb,
        .saved-chats::-webkit-scrollbar-thumb {
            background: var(--primary-gradient);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--shadow-sm);
        }

        .chat-messages::-webkit-scrollbar-thumb:hover,
        .saved-chats::-webkit-scrollbar-thumb:hover {
            background: var(--secondary-gradient);
            box-shadow: var(--shadow-md);
        }

        .chat-messages::-webkit-scrollbar-corner,
        .saved-chats::-webkit-scrollbar-corner {
            background: transparent;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 200px;
            color: #666;
            text-align: center;
        }

        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 14px;
            margin-bottom: 8px;
        }

        .empty-state-subtext {
            font-size: 12px;
            opacity: 0.7;
        }

        /* Enhanced Markdown Styling */
        .message-content h1,
        .message-content h2,
        .message-content h3,
        .message-content h4,
        .message-content h5,
        .message-content h6 {
            color: #1f2937;
            margin: 16px 0 12px 0;
            font-weight: 600;
            line-height: 1.3;
        }

        .message-content h1 {
            font-size: 24px;
        }

        .message-content h2 {
            font-size: 21px;
        }

        .message-content h3 {
            font-size: 18px;
        }

        .message-content h4 {
            font-size: 16px;
        }

        .message-content h5 {
            font-size: 14px;
        }

        .message-content h6 {
            font-size: 13px;
        }

        .message.user .message-content p {
            margin: 8px 0;
            line-height: 1.6;
            color: #000;
        }

        .message.bot .message-content p {
            margin: 8px 0;
            line-height: 1.6;
            color: #374151;

        }

        .message-content strong {
            font-weight: bold;
            color: black;
            /* background: white; */
            -webkit-background-clip: text;
            /* -webkit-text-fill-color: transparent; */
            background-clip: text;
        }

        .message.user .message-content strong {
            font-weight: bold;
            color: #fff;
            background: transparent;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .message-content em {
            color: #6b7280;
            font-style: italic;
            font-size: 0.95em;
        }

        .message-content ul,
        .message-content ol {
            margin: 12px 0;
            padding-left: 24px;
            line-height: 1.6;
            text-align: left;
            align-items: left;
        }

        .message-content li {
            margin: 6px 0;
            color: #374151;
        }

        .message-content code {
            background: #f3f4f6;
            color: #dc2626;
            padding: 2px 6px;
            font-size: 0.9em;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        .message-content blockquote {
            border-left: 4px solid #3b82f6;
            margin: 16px 0;
            padding: 12px 16px;
            background: #f8fafc;
            border-radius: 0 8px 8px 0;
            color: #4b5563;
            font-style: italic;
        }

        /* Modern Micro-interactions and Animations */
        .chat-item-title,
        .option-name {
            background: linear-gradient(90deg, var(--text-primary), var(--primary-600));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            transition: all var(--transition-normal);
        }

        .chat-item:hover .chat-item-title,
        .option-card:hover .option-name {
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .message.bot .message-content,
        .message.user .message-content {
            animation: messageSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes messageSlideIn {
            0% {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }

            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .unified-cot-response-panel {
            animation: panelExpand 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes panelExpand {
            0% {
                opacity: 0;
                transform: scale(0.9) translateY(10px);
                max-height: 0;
            }

            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
                max-height: none;
            }
        }

        /* Loading states and feedback */
        .loading-pulse {
            animation: loadingPulse 1.5s ease-in-out infinite;
        }

        @keyframes loadingPulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        /* Enhanced focus states for accessibility */
        .message-input:focus,
        .send-btn:focus,
        .new-chat-btn:focus,
        .theme-toggle:focus,
        .option-card:focus,
        .confirm-btn:focus {
            outline: 2px solid var(--primary-500);
            outline-offset: 2px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .chat-sidebar {
                width: 240px;
            }

            .sidebar-header {
                padding: 15px;
            }

            .chat-item {
                padding: 10px 15px;
            }

            .chat-messages {
                padding: 15px;
            }

            .message .message-content {
                font-size: 13px;
            }

            .option-name {
                font-size: 13px;
            }

            .option-subtitle {
                font-size: 11px;
            }

            .avatar {
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .input-container {
                padding: 12px 15px;
            }

            .message-input {
                font-size: 13px;
                padding: 10px 14px;
            }

            .send-btn {
                width: 36px;
                height: 36px;
                font-size: 14px;
            }

            /* COT Responsive adjustments */
            .chain-container {
                max-width: min(95vw, 500px);
            }

            .typing-indicator {
                min-width: 280px;
                max-width: min(95vw, 600px);
                padding: 16px 20px;
            }

            .chain-item {
                padding: 14px 18px;
                gap: 14px;
                min-height: 50px;
            }

            .chain-loader,
            .chain-check {
                width: 20px;
                height: 20px;
            }

            .unified-cot-response-panel .chain-container {
                padding: 20px 24px;
            }

            .unified-cot-response-panel .chain-item {
                padding: 16px 20px;
                min-height: 60px;
            }
        }

        @media (max-width: 480px) {
            .chat-sidebar {
                width: 200px;
            }

            .chat-item-title {
                font-size: 13px;
            }

            .chat-item-preview {
                font-size: 11px;
            }
        }

        /* COT Section Styling */
        .cot-section {
            margin-top: 12px;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s ease;
            max-height: 1000px;
            /* Adjust based on your needs */
        }

        .cot-section.collapsed {
            max-height: 40px;
            /* Just enough to show the header */
        }

        .cot-header {
            background: rgba(102, 126, 234, 0.08);
            padding: 10px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px;
            transition: background-color 0.2s ease;
        }

        .cot-header:hover {
            background: rgba(102, 126, 234, 0.15);
        }

        .header-content {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #4f46e5;
            font-size: 14px;
        }

        .header-loading {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .toggle-icon {
            transition: transform 0.3s ease;
            color: #4f46e5;
            font-size: 12px;
        }

        .cot-section.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .chain-container {
            padding: 12px 0;
            transition: max-height 0.3s ease;
            overflow: hidden;
        }

        /* Chain Item Styling */
        .chain-item {
            display: flex;
            align-items: flex-start;
            padding: 10px 16px;
            margin: 4px 0;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.7);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .chain-item:hover {
            background: rgba(255, 255, 255, 0.9);
            transform: translateX(2px);
        }

        .chain-check {
            margin-right: 10px;
            color: #10b981;
            font-weight: bold;
            min-width: 20px;
        }

        .chain-text {
            flex: 1;
            font-size: 13px;
            line-height: 1.5;
            color: #374151;
        }

        /* Typing Indicator Styling */
        .typing-indicator {
            padding: 12px 16px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }

        .typing-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .typing-main-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .typing-main-text {
            font-size: 14px;
            color: #4b5563;
            font-weight: 500;
        }

        .typing-dots {
            display: flex;
            gap: 2px;
        }

        .typing-dot {
            font-size: 24px;
            line-height: 1;
            color: #4f46e5;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .typing-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .typing-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {

            0%,
            80%,
            100% {
                transform: translateY(0);
                opacity: 0.5;
            }

            40% {
                transform: translateY(-5px);
                opacity: 1;
            }
        }

        /* Dark Mode Support */
        :root[data-theme="dark"] .cot-header {
            background: rgba(102, 126, 234, 0.15);
        }

        :root[data-theme="dark"] .cot-header:hover {
            background: rgba(102, 126, 234, 0.25);
        }

        :root[data-theme="dark"] .chain-item {
            background: rgba(30, 41, 59, 0.7);
            color: #e2e8f0;
        }

        :root[data-theme="dark"] .chain-item:hover {
            background: rgba(30, 41, 59, 0.9);
        }

        :root[data-theme="dark"] .chain-text {
            color: #e2e8f0;
        }

        :root[data-theme="dark"] .typing-indicator {
            background: rgba(30, 41, 59, 0.9);
            color: #e2e8f0;
        }

        :root[data-theme="dark"] .typing-main-text {
            color: #e2e8f0;
        }
    </style>
</head>

<body>
    <!-- Floating Particles Background -->
    <!-- <div class="floating-particles">
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
    </div> -->

    <!-- Chat Bot Container -->
    <div class="chat-bot-container active" id="chatContainer">


        <div class="chat-sidebar">
            <div class="sidebar-header">
                <h1>
                    AI Assist
                </h1>
            </div>
            <div style="width: 100%;display: flex;
    align-content: center;
    justify-content: center;
    align-items: center;">
                <button class="new-chat-btn" id="newChatBtn">
                    <span>+</span>
                    New Chat
                </button>
            </div>

            <div class="saved-chats">
                <div class="saved-chats-header">Saved Chats</div>
                <div id="savedChatsList">
                    <!-- Saved chats will be populated here -->
                </div>
            </div>
        </div>
        <div class="chat-main">
            <!-- Sidebar -->
            <div class="chat-header">
                <h1>
                    <div class="bot-icon message-avatar"></div>
                    <!-- <div class="bot-bot">HA</div> -->
                    AI Assistant
                </h1>
                <div class="chat-controls">
                    <button class="close-btn" id="closeBtn">
                        <svg width="800px" height="800px" viewBox="0 0 24 24" fill="white"
                            xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M18 3.70825C19.2447 5.11852 20 6.97101 20 8.9999C20 11.0288 19.2447 12.8813 18 14.2915M6 3.70825C4.75527 5.11852 4 6.97101 4 8.9999C4 11.0288 4.75527 12.8813 6 14.2915"
                                stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path
                                d="M15 6.35425C15.6224 7.05938 16 7.98563 16 9.00007C16 10.0145 15.6224 10.9408 15 11.6459M9 6.35425C8.37764 7.05938 8 7.98563 8 9.00007C8 10.0145 8.37764 10.9408 9 11.6459"
                                stroke="#000000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                            <path d="M12 9V20" stroke="#000000" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" />
                        </svg>
                    </button>
                </div>
            </div>
            <!-- Chat Content -->
            <div class="chat-content">
                <div class="chat-messages" id="chatMessages" role="log" aria-live="polite" aria-relevant="additions">
                    <!-- Messages will be populated here -->
                </div>

                <div class="input-container">
                    <textarea rows="2" class="message-input" id="messageInput"
                        placeholder="Type your message... (Shift+Enter for newline)"></textarea>
                    <button class="send-btn" id="sendBtn"></button>
                </div>
                <button class="scroll-to-bottom" id="scrollToBottomBtn" title="Scroll to latest"> New messages</button>
            </div>
        </div>
    </div>

    <script>// Healthcare Chat Application with Complete History Management
        // Fixed version with proper chat isolation and state management

        // ==================== State Management ====================
        let sessionId = '';
        let isAuth = false;
        let isProcessing = false;
        let bookingContext = {};
        let currentResponseTag = '';
        let followedBy = null;
        let currentChatId = null;
        let currentChainOfThoughts = []; // Store current chain of thoughts
        let currentMessageId = null; // Track current message being processed
        let cotStorage = {}; // Store COT data by message ID: { messageId: [...cotSteps] }
        let currentChatData = {
            id: null,
            title: '',
            messages: [],
            createdAt: new Date(),
            lastMessageTime: new Date(),
            // Store chat-specific state
            sessionId: '',
            bookingContext: {},
            currentResponseTag: '',
            followedBy: null,
            cotData: {} // Store COT data mapped by message ID

        };

        // Function to generate unique message ID
        function generateMessageId() {
            return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // ==================== Socket.IO Configuration ====================
        let socket = null;
        const SOCKET_URL = 'http://localhost:9045'; // Adjust this to match your backend URL
        let currentTypingIndicator = null;

        // Theme management
        function applyTheme(theme) {
            const root = document.documentElement;
            root.setAttribute('data-theme', theme);
            // Switch highlight.js theme
            const hl = document.getElementById('hljsTheme');
            if (hl) {
                const base = 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/';
                hl.href = theme === 'dark' ? base + 'github-dark.min.css' : base + 'github.min.css';
            }
            localStorage.setItem('chatTheme', theme);
        }
        function initTheme() {
            const saved = localStorage.getItem('chatTheme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
            applyTheme(saved || (prefersDark ? 'light' : 'light'));
        }

        // Initialize Markdown configuration
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false,
            sanitize: false,
            silent: true,
            smartLists: true,
            smartypants: false,
            xhtml: false,
            highlight: function (code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (err) { }
                }
                try {
                    return hljs.highlightAuto(code).value;
                } catch (err) { }
                return code;
            }
        });

        // API Configuration
        const API_CONFIG = {
            baseUrl: 'http://localhost:9045/api/ai/chat',
            continueUrl: 'http://localhost:9045/api/ai/chat/continue',
            headers: {
                'Content-Type': 'application/json',
                'employee_id': '702',
                'token': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoidGVzdF9wcm9kQG1lYXN1cmUuY29tIiwiZXhwIjoxNzU1MDc3Mjg0LCJpc3MiOiJNUE1BdXRoZW50aWNhdGlvblNlcnZlciIsImF1ZCI6Ik1QTVNlcnZpY2VQb3N0bWFuQ2xpZW50In0.4Fp9LuD8iFpKo0DasSRctPo4isgKSOQ7v49zUM2pTA4',
                'siteId': '2',
                'siteIdTxt': 'Mbr96uiCgLYPVtXxL6HvQw==',
                'session': ''
            }
        };
        async function initializeSession(shouldShowWelcome = true) {
            let sessionId = localStorage.getItem("chatSession");

            const response = await fetch("http://localhost:9045/api/ai/chat/init", {
                method: "POST",
                headers: sessionId ? { "session": sessionId } : {}
            });

            const data = await response.json();
            sessionId = data.session;
            localStorage.setItem("chatSession", sessionId);

            API_CONFIG.headers.session = sessionId;
            currentChatData.sessionId = sessionId;

            const welcomeKey = `welcomeShown_${sessionId}`;

            if (Array.isArray(data.messages) && data.messages.length > 0) {
                currentChatData.messages = data.messages;
                renderMessages(data.messages);
            } else {
                if (shouldShowWelcome && !localStorage.getItem(welcomeKey)) {
                    showWelcomeMessage();
                    localStorage.setItem(welcomeKey, "true");
                }
            }

            setupProcessingListener(sessionId);
        }

        // ==================== Socket.IO Functions ====================
        function initializeSocket() {
            if (socket) {
                socket.disconnect();
            }

            socket = io(SOCKET_URL, {
                transports: ['websocket', 'polling'],
                autoConnect: true,
                reconnection: true,
                reconnectionAttempts: 5,
                reconnectionDelay: 1000
            });

            socket.on('connect', () => {
                console.log('Socket connected:', socket.id);
                updateConnectionStatus(true);
                // Re-setup processing listener for current session if available
                if (sessionId) {
                    setupProcessingListener(sessionId);
                }
            });

            socket.on('disconnect', (reason) => {
                console.log('Socket disconnected:', reason);
                updateConnectionStatus(false);
                // Clear current typing indicator reference since we can't receive updates
                if (currentTypingIndicator) {
                    const typingTextElement = currentTypingIndicator.querySelector('span');
                    if (typingTextElement) {
                        typingTextElement.textContent = 'AI Processing your request (disconnected)';
                    }
                }
            });

            socket.on('reconnect', (attemptNumber) => {
                console.log('Socket reconnected after', attemptNumber, 'attempts');
                updateConnectionStatus(true);
                // Re-setup processing listener for current session if available
                if (sessionId) {
                    setupProcessingListener(sessionId);
                }
                // Update typing indicator if active
                if (currentTypingIndicator) {
                    const typingTextElement = currentTypingIndicator.querySelector('span');
                    if (typingTextElement && typingTextElement.textContent.includes('disconnected')) {
                        typingTextElement.textContent = 'AI Processing your request';
                    }
                }
            });

            socket.on('connect_error', (error) => {
                console.error('Socket connection error:', error);
                updateConnectionStatus(false);
            });

            socket.on('reconnect_error', (error) => {
                console.error('Socket reconnection error:', error);
                updateConnectionStatus(false);
            });

            socket.on('reconnect_failed', () => {
                console.error('Socket reconnection failed');
                updateConnectionStatus(false);
            });

            socket.on('error', (error) => {
                console.error('Socket error:', error);
                updateConnectionStatus(false);
            });


        }

        function updateHeaderToComplete() {
            const headerLoading = document.querySelector('.header-loading');
            if (headerLoading) {
                headerLoading.innerHTML = `
            <div class="chain-check"></div>
            <div class="chain-text">Analysis complete</div>
        `;
                headerLoading.classList.add('completed');
            }
        }


        // Centralized function to update connection status
        function updateConnectionStatus(isConnected) {
            const connectionDot = document.getElementById('connectionDot');
            if (!connectionDot) return;

            if (isConnected) {
                connectionDot.classList.add('connected');
                connectionDot.title = 'Connected to server';
            } else {
                connectionDot.classList.remove('connected');
                connectionDot.title = 'Disconnected from server';
            }

            // Optional: Add a brief animation to indicate status change
            connectionDot.style.transform = 'scale(1.2)';
            setTimeout(() => {
                connectionDot.style.transform = 'scale(1)';
            }, 200);
        }

        // Add this function to create a typing effect
        function typeWriter(element, text, speed = 20, callback) {
            let i = 0;
            element.textContent = ''; // Clear existing content
            function type() {
                if (i < text.length) {
                    element.textContent += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                } else if (callback) {
                    callback();
                }
            }
            type();
        }

        // Update the chain container population logic
        function populateChainContainer(container, thoughts, index = 0) {
            if (index >= thoughts.length) return;

            const thought = thoughts[index];
            const item = document.createElement('div');
            item.className = `chain-item ${thought.completed ? 'completed' : 'processing'}`;

            const loader = document.createElement('div');
            loader.className = thought.completed ? 'chain-check' : 'chain-loader';
            if (thought.completed) loader.textContent = '';

            const text = document.createElement('div');
            text.className = 'chain-text';

            item.appendChild(loader);
            item.appendChild(text);
            container.appendChild(item);

            // Add the typing effect
            typeWriter(text, thought.message, 10, () => {
                // When typing is done for this item, show the next one
                if (!thought.completed) {
                    thought.completed = true;
                    loader.className = 'chain-check';
                    loader.textContent = '';
                }
                setTimeout(() => populateChainContainer(container, thoughts, index + 1), 300);
            });
        }


        function updateChainOfThoughts(thoughts) {
            if (!currentChainContainer) return;

            // Clear existing thoughts
            currentChainContainer.innerHTML = '';
            currentChainOfThoughts = thoughts;

            // Start populating with typing effect
            populateChainContainer(currentChainContainer, thoughts);
        }


        // Function to manually check and update connection status
        function checkConnectionStatus() {
            if (socket) {
                updateConnectionStatus(socket.connected);
                return socket.connected;
            } else {
                updateConnectionStatus(false);
                return false;
            }
        }

        function setupProcessingListener(sessionId) {
            if (!socket || !sessionId) {
                console.warn('Cannot setup processing listener: socket or sessionId not available');
                return;
            }

            const eventProcess = `${sessionId}_process`;
            const eventAuth = `${sessionId}_auth_service`;
            const eventLocation = `${sessionId}_location`;
            const eventFinalSuggestedProvider = `${sessionId}_final_suggested_provider`;
            const userSelection = `${sessionId}_user_selection`;
            const noSufficientData = `${sessionId}_no_sufficient_data`;
            const clientName = `${sessionId}_client_name`;
            console.log(`Setting up listener for event: ${eventProcess}`);

            // Remove all listeners for this session to avoid duplicates and leaks
            socket.off(eventProcess);
            socket.off(eventAuth);
            socket.off(eventLocation);
            socket.off(eventFinalSuggestedProvider);
            socket.off(userSelection);
            socket.off(noSufficientData);
            socket.off(clientName);

            // Helper to handle COT steps (array or object)
            function handleCOTSteps(data) {
                if (!data) return false;
                // If the server sends an object that contains cot steps under a field, normalize
                // Support common keys: cot, cot_steps, chain_of_thought, steps, and nested detail.cot
                let steps = null;
                if (Array.isArray(data)) steps = data;
                else if (Array.isArray(data.cot)) steps = data.cot;
                else if (Array.isArray(data.cot_steps)) steps = data.cot_steps;
                else if (Array.isArray(data.chain_of_thought)) steps = data.chain_of_thought;
                else if (Array.isArray(data.steps)) steps = data.steps;
                else if (data.detail && Array.isArray(data.detail.cot)) steps = data.detail.cot;
                else if (data.detail && Array.isArray(data.detail.chain_of_thought)) steps = data.detail.chain_of_thought;
                if (steps) {
                    console.debug('handleCOTSteps: detected', steps.length, 'steps');
                    steps.forEach((step) => {
                        if (typeof step === 'string') {
                            ensureTypingIndicator();
                            updateTypingIndicatorText({ thought: step });
                        } else if (typeof step === 'object' && step !== null) {
                            ensureTypingIndicator();
                            updateTypingIndicatorText(step);
                        }
                    });
                    return true;
                }
                return false;
            }

            // Ensure we have a typing indicator element to update
            function ensureTypingIndicator() {
                if (!currentTypingIndicator) {
                    showTypingIndicator();
                }
            }

            // Parse incoming socket payloads which may carry a JSON-stringified message
            function parseIncomingData(raw) {
                if (!raw) return raw;
                try {
                    // If the payload is a plain JSON string
                    if (typeof raw === 'string') {
                        const trimmed = raw.trim();
                        if ((trimmed.startsWith('{') || trimmed.startsWith('['))) {
                            return JSON.parse(trimmed);
                        }
                        return raw;
                    }

                    // If payload is an object and contains a 'message' field that's JSON-stringified
                    if (typeof raw === 'object' && raw.message && typeof raw.message === 'string') {
                        const msg = raw.message.trim();
                        if (msg.startsWith('{') || msg.startsWith('[')) {
                            try {
                                const parsed = JSON.parse(msg);
                                // If parsed looks like a structured payload, prefer it
                                if (typeof parsed === 'object') return parsed;
                            } catch (e) {
                                // ignore parse errors
                            }
                        }
                    }
                } catch (e) {
                    // swallow parsing errors
                }
                return raw;
            }

            // _process event
            socket.on(eventProcess, (rawData) => {
                const data = parseIncomingData(rawData);
                console.log(`Received data on event ${eventProcess}:`, data);

                // Normalize payload: server might send { response: [...], content: '', tag_name: '' } or directly an array
                if (!data) return;
                const errorMsg = document.querySelector('.api-error-message');
                if (errorMsg) errorMsg.remove();

                // If server sends an array directly, treat it as response list
                if (Array.isArray(data)) {
                    if (data.final_response == true) {
                        removeTypingIndicator();
                        return;
                    }
                    // If COT steps are present in the same payload, process them first
                    ensureTypingIndicator();
                    const hadCOT = handleCOTSteps(data);
                    const doInsert = () => {
                        insertOptionsIntoTypingIndicator({ response: data }, 'Option');
                        updateHeaderToComplete();
                    };
                    if (hadCOT) setTimeout(doInsert, 80); else doInsert();
                    return;
                }

                // If data contains nested payloads, flatten them
                const payload = data.response || data.detail || data;

                // If payload contains options array, call render
                if (payload && Array.isArray(payload.options || payload)) {
                    const opts = payload.options || payload;
                    // Final options arrival: process COT first if present then render options
                    ensureTypingIndicator();
                    const hadCOT = handleCOTSteps(data);
                    const doInsert = () => {
                        removeTypingIndicator();
                        insertOptionsIntoTypingIndicator({ response: opts, tag_name: data.tag_name || data.tag, content: data.message || data.content || '' }, data.tag_name || 'Option');
                        updateHeaderToComplete();
                        // Persist chat state
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doInsert, 80); else doInsert();
                    return;
                }

                // If payload has content/message, display it (process any COT first)
                if (data.content || data.message) {
                    ensureTypingIndicator();
                    const hadCOT = handleCOTSteps(data);
                    const doAdd = () => {
                        removeTypingIndicator();
                        addMessage(data.content || data.message, false);
                        updateHeaderToComplete();
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doAdd, 80); else doAdd();
                    return;
                }

                // If COT steps are present, handle them (live processing)
                if (handleCOTSteps(data)) return;

                // Fallback: update typing indicator with whatever arrived
                ensureTypingIndicator();
                updateTypingIndicatorText(data);
            });

            // _auth_service event
            socket.on(eventAuth, (rawData) => {
                const data = parseIncomingData(rawData);
                if (!data) return;
                // If the auth response contains options, render them into the current
                // typing indicator (unified COT panel) so the COT and results share the same area.
                if (Array.isArray(data) || (data.response && Array.isArray(data.response))) {
                    const payload = Array.isArray(data) ? { response: data } : data;
                    ensureTypingIndicator();
                    const hadCOT = handleCOTSteps(data);
                    const doInsert = () => {
                        // If we have an active typing indicator with COT, insert options there
                        if (currentTypingIndicator || document.getElementById('typingIndicator')) {
                            insertOptionsIntoTypingIndicator(payload, 'Auth');
                        } else {
                            // Fallback: render as a normal selection message
                            removeTypingIndicator();
                            insertOptionsIntoTypingIndicator(payload, 'Auth');
                        }
                        updateHeaderToComplete();
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doInsert, 80); else doInsert();
                    return;
                }

                if (!handleCOTSteps(data)) {
                    ensureTypingIndicator();
                    updateTypingIndicatorText(data);
                }
            });

            // Helper: render selection options into the existing typing indicator's unified panel
            function insertOptionsIntoTypingIndicator(payload, type = 'Option', shouldUseContinueAPI = false) {
                // Normalize payload shapes: array/object/string -> { response: [], content: '', message: '' }
                let p = payload || {};
                if (Array.isArray(p)) p = { response: p };
                if (!p.response && p.options && Array.isArray(p.options)) p.response = p.options;
                if (!p.content && p.message) p.content = p.message;
                if (!p.message && p.content) p.message = p.content;

                const typingDiv = currentTypingIndicator || document.getElementById('typingIndicator');

                // If there is live COT in typing indicator, prefer inline insertion
                const typingActive = !!typingDiv;
                const hasLiveCOT = typingActive && (currentChainOfThoughts && currentChainOfThoughts.length > 0);
                if (hasLiveCOT) console.debug('insertOptionsIntoTypingIndicator: inserting inline with', currentChainOfThoughts.length, 'COT steps');

                // If there's an active typing indicator with COT and the caller expected inline behavior, insert and persist
                if (hasLiveCOT) {
                    // Ensure the typing indicator shows full COT container
                    const chainContainer = typingDiv.querySelector('.chain-container');
                    const typingIndicatorElem = typingDiv.querySelector('.typing-indicator');
                    const messageContent = typingDiv.querySelector('.message-content');

                    if (typingIndicatorElem) {
                        typingIndicatorElem.className = 'unified-cot-response-panel';
                        const dots = typingIndicatorElem.querySelector('.typing-dots');
                        if (dots) dots.remove();
                    }

                    // Create a separator between COT and response
                    const existingSeparator = typingDiv.querySelector('.cot-response-separator');
                    if (!existingSeparator) {
                        const separator = document.createElement('div');
                        separator.className = 'cot-response-separator';
                        separator.innerHTML = '<div class="separator-line"></div><div class="separator-label">AI Response</div><div class="separator-line"></div>';
                        if (messageContent) messageContent.appendChild(separator);
                    }

                    // Append response content if present
                    if (p.content || p.message) {
                        const respDiv = document.createElement('div');
                        respDiv.className = 'bot-response-content';
                        respDiv.innerHTML = parseMarkdownContent(p.content || p.message);
                        if (messageContent) messageContent.appendChild(respDiv);
                    }

                    // Render options/cards inline
                    if (p.response && Array.isArray(p.response) && p.response.length > 0) {
                        const optionsSection = document.createElement('div');
                        optionsSection.className = 'cards-section';
                        const title = document.createElement('div');
                        title.className = 'section-title';
                        title.textContent = `${getTypeIcon(type)} Choose your ${type}:`;
                        messageContent.appendChild(title);

                        const colors = ['#fa9d9d', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#FFB6C1', '#98FB98'];

                        p.response.forEach((optionValue, index) => {
                            let optionCard = document.createElement('div');
                            optionCard.className = 'option-card';
                            const color = colors[index % colors.length];

                            let optionName = '';
                            let optionId = '';
                            let optionSubtext = '';
                            let optionData = optionValue;

                            if (typeof optionValue === 'string') {
                                optionName = optionValue;
                                optionSubtext = getTypeSubtitle(type, optionName);
                            } else if (typeof optionValue === 'object' && optionValue !== null) {
                                optionName = optionValue.name || optionValue.title || optionValue.label || optionValue.text || optionValue.doctor_name || optionValue.client_name || optionValue.location_name || 'Option';
                                optionId = optionValue.value || '';
                                optionSubtext = optionValue.subtitle || optionValue.description || optionValue.details || '';
                            } else {
                                optionName = String(optionValue);
                            }

                            const displayName = formatOptionName(optionName);
                            const parts = displayName.split('=>').map(s => s.trim());

                            if (parts.length > 1) {
                                optionCard.innerHTML = `<div class="avatar" style="background: linear-gradient(135deg, ${color}, ${color}CC)">${getTypeIcon(type)}</div>
                        <ul class="option-name option-list-card" title="${displayName}">` +
                                    parts.map(part => `<li class="option-list-item">${part}</li>`).join('') +
                                    `</ul></div>`;
                            } else {
                                optionCard.innerHTML = `
                        <div class="avatar" style="background: linear-gradient(135deg, ${color}, ${color}CC)">${getTypeIcon(type)}</div>
                        <div class="option-info">
                            <div class="option-name">${displayName}</div>
                            <div class="option-subtitle">${optionSubtext}</div>
                        </div>
                    `;
                            }

                            optionCard.addEventListener('click', async () => {
                                document.querySelectorAll('.option-card, .employee-card').forEach(card => card.classList.remove('selected'));
                                optionCard.classList.add('selected');
                                addMessage(`Use ${optionName}`, true);

                                if (followedBy !== null && !isAuth) {
                                    await makeContinueAPICall(optionId || optionValue, p.tag_name || p.tag || type, followedBy);
                                } else {
                                    const selectionMessage = typeof optionData === 'object' ? (optionData.id || optionName) : getSelectionMessage(type, optionName);
                                    handleMessage(selectionMessage);
                                }
                            });

                            optionsSection.appendChild(optionCard);
                        });

                        messageContent.appendChild(optionsSection);
                    }
                    // Persist this unified selection into chat history with COT if present
                    try {
                        const savedMessageId = addMessageToCurrentChat(p.content || p.message || '', false, 'selection', {
                            options: p,
                            message: p.content || p.message || '',
                            optionType: type,
                            shouldUseContinueAPI: !!p.followedBy || shouldUseContinueAPI || false
                        });

                        const cotCopy = currentChainOfThoughts && currentChainOfThoughts.length > 0 ? [...currentChainOfThoughts] : [];
                        if (cotCopy.length > 0) {
                            if (!currentChatData.cotData) currentChatData.cotData = {};
                            currentChatData.cotData[savedMessageId] = cotCopy;
                            cotStorage[savedMessageId] = cotCopy;
                            const msgEntry = currentChatData.messages.find(m => m.id === savedMessageId);
                            if (msgEntry) {
                                msgEntry.hasCOT = true;
                                msgEntry.cotId = savedMessageId;
                            }
                        }
                        removeTypingIndicator();
                        updateHeaderToComplete();
                        saveCurrentChat();
                    } catch (e) {
                        console.warn('Failed to persist inserted options:', e);
                    }

                    const messagesContainer = document.getElementById('chatMessages');
                    if (messagesContainer) messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    return;
                }

                // No active COT or typing indicator - render as a normal selection message (fallback)
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message bot';

                const avatar = document.createElement('div');
                avatar.className = 'message-avatar-response';
                avatar.textContent = 'HA';
                avatar.style.color = '#fff !important';
                avatar.style.backgroundColor = 'transparent !important';
                messageDiv.appendChild(avatar);

                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';

                if (p.content) {
                    const textDiv = document.createElement('div');
                    textDiv.innerHTML = parseMarkdownContent(p.content || p.message);
                    textDiv.style.marginBottom = '15px';
                    messageContent.appendChild(textDiv);
                }

                const isEmployeeData = p.response && p.response.length > 0 && typeof p.response[0] === 'object' &&
                    (p.response[0].EmployeeId || p.response[0].EmployeeFullName || p.response[0].match_score !== undefined);

                let optionsSection;
                if (isEmployeeData) {
                    optionsSection = document.createElement('div');
                    optionsSection.className = 'employee-cards-section';

                    const title = document.createElement('div');
                    title.className = 'section-title';
                    title.innerHTML = ` Select Your Healthcare Provider:`;
                    messageContent.appendChild(title);
                } else {
                    optionsSection = document.createElement('div');
                    optionsSection.className = 'cards-section scrollable-row';

                    const title = document.createElement('div');
                    title.className = 'section-title';
                    title.innerHTML = `${getTypeIcon(type)} Choose your ${type}:`;
                    messageContent.appendChild(title);
                }

                const colors = ['#fa9d9d', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#FFB6C1', '#98FB98'];

                (p.response || []).forEach((optionValue, index) => {
                    let optionCard, optionName, optionSubtext, optionId, optionData;

                    if (optionValue && optionValue.EmployeeId) {
                        optionCard = createEmployeeCard(optionValue, index);
                        optionName = optionValue.EmployeeFullName;
                        optionId = optionValue.EmployeeId;
                        optionData = optionValue;
                    } else {
                        optionCard = document.createElement('div');
                        optionCard.className = 'option-card';
                        const color = colors[index % colors.length];

                        if (typeof optionValue === 'string') {
                            optionName = optionValue;
                            optionSubtext = getTypeSubtitle(type, optionValue);
                            optionId = optionValue;
                            optionData = optionValue;
                        } else if (typeof optionValue === 'object' && optionValue !== null) {
                            optionData = optionValue;
                            optionName = optionValue.name || optionValue.value || optionValue.title || optionValue.label ||
                                optionValue.doctor_name || optionValue.client_name || optionValue.patient_name ||
                                optionValue.location_name || optionValue.service_name || optionValue.time_slot ||
                                optionValue.slot || optionValue.date || optionValue.appointment_date || optionValue.text || 'Option';

                            optionSubtext = optionValue.subtitle || optionValue.description || optionValue.specialty ||
                                optionValue.details || optionValue.info || optionValue.room || optionValue.duration ||
                                optionValue.availability || getTypeSubtitle(type, optionName);

                            optionId = optionValue.id || optionValue.value || optionValue.key || optionValue.doctor_id ||
                                optionValue.client_id || optionValue.location_id || optionValue.service_id ||
                                optionValue.slot_id || optionName;
                        } else {
                            optionName = String(optionValue);
                            optionSubtext = getTypeSubtitle(type, optionName);
                            optionId = optionName;
                            optionData = optionValue;
                        }

                        let optionNameHtml = '';
                        if (optionName) {
                            const displayName = formatOptionName(optionName);
                            const parts = displayName.split('=>').map(s => s.trim());
                            if (parts.length > 1) {
                                optionNameHtml = `<ul class="option-name option-list-card" title="${displayName}">` +
                                    parts.map(part => `<li class="option-list-item">${part}</li>`).join('') +
                                    `</ul>`;
                            } else {
                                optionNameHtml = `<div class="option-name option-single-card" title="${displayName}">${displayName}</div>`;
                            }
                        }
                        optionCard.innerHTML = `
                    <div class="avatar" style="background: linear-gradient(135deg, ${color}, ${color}CC)">
                        ${getTypeIcon(type)}
                    </div>
                    <div class="option-info">
                        ${optionNameHtml}
                        <div class="option-subtitle" title="${optionSubtext}">${optionSubtext}</div>
                    </div>
                `;
                    }

                    optionCard.addEventListener('click', async () => {
                        document.querySelectorAll('.option-card, .employee-card').forEach(card => {
                            card.classList.remove('selected');
                        });
                        optionCard.classList.add('selected');

                        if (isEmployeeData && optionData && optionData.EmployeeId) {
                            bookingContext.employee = optionName;
                            bookingContext.employeeId = optionId;
                            bookingContext.employeeData = optionData;
                            bookingContext.provider = optionName;
                            bookingContext.providerId = optionId;
                            bookingContext.providerData = optionData;
                        } else {
                            const typeLower = type.toLowerCase();
                            if (typeLower.includes('client') || typeLower.includes('patient')) {
                                bookingContext.client = optionName;
                                bookingContext.clientId = optionId;
                                bookingContext.clientData = optionData;
                            } else if (typeLower.includes('doctor') || typeLower.includes('therapist')) {
                                bookingContext.doctor = optionName;
                                bookingContext.doctorId = optionId;
                                bookingContext.doctorData = optionData;
                            } else if (typeLower.includes('location')) {
                                bookingContext.location = optionName;
                                bookingContext.locationId = optionId;
                                bookingContext.locationData = optionData;
                            } else if (typeLower.includes('time')) {
                                bookingContext.time = optionName;
                                bookingContext.timeId = optionId;
                                bookingContext.timeData = optionData;
                            } else if (typeLower.includes('date')) {
                                bookingContext.date = optionName;
                                bookingContext.dateId = optionId;
                                bookingContext.dateData = optionData;
                            } else if (typeLower.includes('service')) {
                                bookingContext.service = optionName;
                                bookingContext.serviceId = optionId;
                                bookingContext.serviceData = optionData;
                            } else {
                                bookingContext[`selected_${typeLower}`] = optionName;
                                bookingContext[`selected_${typeLower}_id`] = optionId;
                                bookingContext[`selected_${typeLower}_data`] = optionData;
                            }
                        }

                        addMessage(`Use ${optionName}`, true);

                        const typingIndicator = showTypingIndicator();
                        try {
                            if (followedBy !== null && !isAuth) {
                                await makeContinueAPICall(optionId || optionName, p.tag_name || p.tag || type, followedBy);
                            } else {
                                let selectionMessage;
                                if (typeof optionData === 'object' && optionData !== null) {
                                    selectionMessage = optionId || optionName;
                                } else {
                                    selectionMessage = getSelectionMessage(type, optionName);
                                }
                            }

                            removeTypingIndicator();
                        } catch (error) {
                            removeTypingIndicator();
                            addMessage("Sorry, there was an error processing your selection. Please try again.");
                            console.error('Selection error:', error);
                        }
                    });
                    optionsSection.appendChild(optionCard);
                });

                messageContent.appendChild(optionsSection);
                messageDiv.appendChild(messageContent);
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;

                const savedMessageId = addMessageToCurrentChat('', false, 'selection', {
                    options: p,
                    message: p.content || p.message || '',
                    optionType: type,
                    shouldUseContinueAPI: shouldUseContinueAPI
                });

                if (currentChainOfThoughts && currentChainOfThoughts.length > 0) {
                    if (!currentChatData.cotData) currentChatData.cotData = {};
                    currentChatData.cotData[savedMessageId] = [...currentChainOfThoughts];
                    cotStorage[savedMessageId] = [...currentChainOfThoughts];
                    const msgEntry = currentChatData.messages.find(m => m.id === savedMessageId);
                    if (msgEntry) {
                        msgEntry.hasCOT = true;
                        msgEntry.cotId = savedMessageId;
                    }
                }

                saveCurrentChat();

                // Scroll into view
                const messagesContainer = document.getElementById('chatMessages');
                if (messagesContainer) messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            // _location event
            socket.on(eventLocation, (rawData) => {
                const data = parseIncomingData(rawData);
                if (!data) return;
                if (Array.isArray(data) || (data.response && Array.isArray(data.response))) {
                    const payload = Array.isArray(data) ? { response: data } : data;
                    ensureTypingIndicator();
                    const hadCOT = handleCOTSteps(data);
                    const doInsert = () => {
                        // If we have an active typing indicator with COT, insert options there
                        if (currentTypingIndicator || document.getElementById('typingIndicator')) {
                            insertOptionsIntoTypingIndicator(payload, 'Auth');
                        } else {
                            // Fallback: render as a normal selection message
                            removeTypingIndicator();
                            insertOptionsIntoTypingIndicator(payload, 'Auth');
                        }
                        updateHeaderToComplete();
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doInsert, 80); else doInsert();
                    return;
                }

                if (!handleCOTSteps(data)) {
                    ensureTypingIndicator();
                    updateTypingIndicatorText(data);
                }
            });

            // _no_sufficient_data event
            socket.on(noSufficientData, (rawData) => {
                const data = parseIncomingData(rawData);
                console.log(` No sufficient data update for session ${sessionId}:`, data);
                ensureTypingIndicator();
                const hadCOT = handleCOTSteps(data);
                if (data && data.response && Array.isArray(data.response)) {
                    const doInsert = () => {
                        removeTypingIndicator();
                        insertOptionsIntoTypingIndicator({ response: data.response, content: data.content || data.message || '' }, 'NoData');
                        updateHeaderToComplete();
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doInsert, 80); else doInsert();
                    return;
                }
                if (!hadCOT) updateTypingIndicatorText(data);
            });

            // _client_name event
            socket.on(clientName, (rawData) => {
                const data = parseIncomingData(rawData);
                console.log(` Client name update for session ${sessionId}:`, data);
                ensureTypingIndicator();
                const hadCOT = handleCOTSteps(data);
                if (data && data.response && Array.isArray(data.response)) {
                    const doInsert = () => {
                        removeTypingIndicator();
                        insertOptionsIntoTypingIndicator({ response: data.response, content: data.content || data.message || '' }, 'Client');
                        updateHeaderToComplete();
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doInsert, 80); else doInsert();
                    return;
                }
                if (!hadCOT) updateTypingIndicatorText(data);
            });

            // _user_selection event
            socket.on(userSelection, (rawData) => {
                const data = parseIncomingData(rawData);
                console.log(` Received processing update for session ${sessionId}:`, data);
                ensureTypingIndicator();
                const hadCOT = handleCOTSteps(data);
                // userSelection may send a full detail object or an array
                if (data && (Array.isArray(data) || (data.response && Array.isArray(data.response)))) {
                    const doInsert = () => {
                        removeTypingIndicator();
                        insertOptionsIntoTypingIndicator({ response: data.response || data, content: data.message || data.content || '' }, 'Selection');
                        updateHeaderToComplete();
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doInsert, 80); else doInsert();
                    return;
                }
                // If final confirmation or success included
                if (data && (data.final || data.completed || data.detail?.final_response || data.message && data.message.includes('Appointment Saved'))) {
                    const doFinal = () => {
                        removeTypingIndicator();
                        if (data.message || data.content) addMessage(data.message || data.content, false);
                        updateHeaderToComplete();
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doFinal, 80); else doFinal();
                    return;
                }
                if (!hadCOT) updateTypingIndicatorText(data);
            });

            // _final_suggested_provider event
            socket.on(eventFinalSuggestedProvider, (rawData) => {
                const data = parseIncomingData(rawData);
                console.log(` eventFinalSuggestedProvider update for session ${sessionId}:`, data);
                ensureTypingIndicator();
                const hadCOT = handleCOTSteps(data);
                if (data && data.response && Array.isArray(data.response)) {
                    const doInsert = () => {
                        removeTypingIndicator();
                        insertOptionsIntoTypingIndicator({ response: data.response, content: data.content || data.message || '' }, 'Provider');
                        updateHeaderToComplete();
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doInsert, 80); else doInsert();
                    return;
                }
                // If final message provided
                if (data && (data.final || data.completed || data.detail?.final_response)) {
                    const doFinal = () => {
                        removeTypingIndicator();
                        if (data.message || data.content) addMessage(data.message || data.content, false);
                        updateHeaderToComplete();
                        saveCurrentChat();
                    };
                    if (hadCOT) setTimeout(doFinal, 80); else doFinal();
                    return;
                }
                if (!hadCOT) updateTypingIndicatorText({
                    ...data,
                    thought: data && (data.message || data.thought) ? (data.message || data.thought) : 'Processing location data...'
                });
            });

            console.log(` Socket listener active for: ${eventProcess}`);
        }


        function updateTypingIndicatorText(data) {
            if (!currentTypingIndicator) return;

            const typingMainText = currentTypingIndicator.querySelector('.typing-main-text');
            const chainContainer = currentTypingIndicator.querySelector('.chain-container');
            if (!typingMainText) return;

            let displayText = 'AI Processing your request';
            let chainMessage = null;
            let isCompleted = false;

            // Enhanced: handle tag_name for COT completion
            if (data && typeof data === 'object') {
                if (
                    (data.tag_name === 'auth_service' || data.tag_name === 'location' || data.tag_name === 'final_suggested_provider') &&
                    data.response
                ) {
                    isCompleted = true;
                    displayText = ` ${data.tag_name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase())} Options Ready`;
                    chainMessage = `${data.tag_name.replace(/_/g, ' ')} response received`;
                }
            }

            try {
                if (data && typeof data === 'object') {
                    // Try various possible field names for the processing update
                    if (data.thought) {
                        displayText = ` ${data.thought}`;
                        chainMessage = data.thought;
                    } else if (data.message) {
                        displayText = ` ${data.message}`;
                        chainMessage = data.message;
                    } else if (data.step) {
                        displayText = ` ${data.step}`;
                        chainMessage = data.step;
                    } else if (data.chain_of_thought) {
                        displayText = ` ${data.chain_of_thought}`;
                        chainMessage = data.chain_of_thought;
                    } else if (data.status) {
                        displayText = ` ${data.status}`;
                        chainMessage = data.status;
                    } else if (data.action) {
                        displayText = ` ${data.action}`;
                        chainMessage = data.action;
                    } else if (data.reasoning) {
                        displayText = ` ${data.reasoning}`;
                        chainMessage = data.reasoning;
                    } else if (data.progress) {
                        displayText = ` ${data.progress}`;
                        chainMessage = data.progress;
                    } else if (data.text || data.content) {
                        displayText = data.text || data.content;
                        chainMessage = data.text || data.content;
                    }

                    // Add completion status indicator if completed
                    if (isCompleted || data.completed || data.final_response || data.status === 'completed') {
                        displayText += ' ';
                    }
                } else if (typeof data === 'string' && data.trim()) {
                    displayText = data.trim();
                    chainMessage = data.trim();
                }

                // Ensure the text is not too long
                if (displayText.length > 120) {
                    displayText = displayText.substring(0, 117) + '...';
                }

                // Update the main typing text with subtle animation
                if (typingMainText.textContent !== displayText) {
                    typingMainText.style.opacity = '0.7';
                    setTimeout(() => {
                        typingMainText.textContent = displayText;
                        typingMainText.style.opacity = '1';
                    }, 120);
                }

                // If we have a chainMessage, handle dynamic COT creation/updating
                if (chainMessage && chainContainer) {
                    handleDynamicChainOfThoughts(chainContainer, chainMessage, data);
                }

            } catch (error) {
                console.error('Error updating typing indicator:', error);
                typingMainText.textContent = 'AI Processing your request';
            }
        }

        // Handle dynamic Chain of Thoughts with loader and completion states
        function handleDynamicChainOfThoughts(chainContainer, chainMessage, data) {
            const shortMsg = String(chainMessage).trim();

            // Determine if this step is completed
            const isCompleted = data.completed || data.status === 'completed' || data.step_completed || false;

            // Generate step ID - use provided ID or create based on content hash
            const stepId = data.step_id || data.id || `step-${shortMsg.substring(0, 20).replace(/\s+/g, '-')}-${Date.now()}`;

            // Check if this is an update to existing step by looking for similar content
            let existingStep = Array.from(chainContainer.children).find(item => {
                const existingText = item.querySelector('.chain-text')?.textContent || '';
                return item.dataset.stepId === stepId || existingText.includes(shortMsg.substring(0, 30));
            });

            if (existingStep && !isCompleted) {
                // Update existing step if it's not completed yet
                updateChainStep(existingStep, shortMsg, isCompleted);
                existingStep.dataset.stepId = stepId; // Update step ID
            } else if (!existingStep) {
                // COMPLETE PREVIOUS STEP: When a new COT step arrives, mark the previous one as completed
                completePreviousStep(chainContainer);

                // Create new step
                createNewChainStep(chainContainer, shortMsg, stepId, isCompleted);
            }

            // Update global chain thoughts array
            updateGlobalChainThoughts(stepId, shortMsg, isCompleted);

            // Scroll to bottom to show latest thought
            chainContainer.scrollTop = chainContainer.scrollHeight;

            // Update header preview if present and collapsed
            try {
                const header = currentTypingIndicator?.querySelector('.cot-header');
                const isCollapsed = header && header.parentElement && header.parentElement.classList.contains('collapsed');
                const latestText = shortMsg;
            } catch (e) { /* non-blocking */ }
        }

        // Create a new chain step with loader or completion state
        function createNewChainStep(chainContainer, message, stepId, isCompleted) {
            const item = document.createElement('div');
            item.className = `chain-item ${isCompleted ? 'completed' : 'processing'}`;
            item.dataset.stepId = stepId;

            const icon = document.createElement('div');
            if (isCompleted) {
                icon.className = 'chain-check';
                icon.innerHTML = '';
            } else {
                icon.className = 'chain-loader';
            }

            const textContent = document.createElement('div');
            textContent.style.flex = '1';

            const textElement = document.createElement('div');
            textElement.className = 'chain-text';
            textElement.textContent = message;

            // const timestamp = document.createElement('div');
            // timestamp.className = 'chain-timestamp';
            // timestamp.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            textContent.appendChild(textElement);
            // textContent.appendChild(timestamp);

            item.appendChild(icon);
            item.appendChild(textContent);

            chainContainer.appendChild(item);

            // Update progress
            updateCOTProgress(chainContainer);

            // Keep the chain to a reasonable length
            const maxItems = 20;
            while (chainContainer.children.length > maxItems) {
                chainContainer.removeChild(chainContainer.children[0]);
                updateCOTProgress(chainContainer); // Update progress after removal
            }
        }

        // Update existing chain step (from processing to completed)
        function updateChainStep(stepElement, message, isCompleted) {
            const textElement = stepElement.querySelector('.chain-text');
            if (textElement) {
                textElement.textContent = message;
            }

            if (isCompleted && !stepElement.classList.contains('completed')) {
                // Mark as completed
                stepElement.classList.remove('processing');
                stepElement.classList.add('completed');

                // Update icon from loader to check
                const icon = stepElement.querySelector('.chain-loader');
                if (icon) {
                    icon.className = 'chain-check';
                    icon.innerHTML = '';
                }

                // // Update timestamp
                // const timestamp = stepElement.querySelector('.chain-timestamp');
                // if (timestamp) {
                //     timestamp.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                // }

                // Update progress
                const chainContainer = stepElement.parentElement;
                if (chainContainer) {
                    updateCOTProgress(chainContainer);
                }
            }
        }

        // Update COT progress bar
        function updateCOTProgress(chainContainer) {
            if (!currentTypingIndicator) return;

            const progressBar = currentTypingIndicator.querySelector('.cot-progress-fill');

            if (!progressBar) return;

            const totalSteps = chainContainer.children.length;
            const completedSteps = chainContainer.querySelectorAll('.chain-item.completed').length;
            const progressPercent = totalSteps > 0 ? (completedSteps / totalSteps) * 100 : 0;

            progressBar.style.width = `${progressPercent}%`;

            // Update progress bar color based on completion
            if (progressPercent === 100) {
                progressBar.style.background = 'var(--success-gradient)';
            } else {
                progressBar.style.background = 'var(--primary-gradient)';
            }
        }

        // Update global chain thoughts array
        function updateGlobalChainThoughts(stepId, message, isCompleted) {
            // Find existing step in global array
            const existingIndex = currentChainOfThoughts.findIndex(thought => thought.stepId === stepId);

            if (existingIndex >= 0) {
                // Update existing
                currentChainOfThoughts[existingIndex] = {
                    stepId,
                    text: message,
                    completed: isCompleted,
                    timestamp: Date.now()
                };
            } else {
                // Add new
                currentChainOfThoughts.push({
                    stepId,
                    text: message,
                    completed: isCompleted,
                    timestamp: Date.now()
                });
            }

            // Keep array length reasonable
            if (currentChainOfThoughts.length > 15) {
                currentChainOfThoughts = currentChainOfThoughts.slice(-15);
            }
        }

        // Create preserved Chain of Thoughts UI for final message
        function createPreservedChainOfThoughts() {
            if (!currentChainOfThoughts || currentChainOfThoughts.length === 0) {
                return null;
            }

            const thinkingProcess = document.createElement('div');
            thinkingProcess.className = 'thinking-process';

            // Create header
            const header = document.createElement('div');
            header.className = 'thinking-header';
            header.innerHTML = `
        <div class="thinking-icon" style="animation: none; border-color: #10b981;"></div>
        <span>Chain of Thoughts - AI Reasoning Process</span>
    `;
            thinkingProcess.appendChild(header);

            // Create steps container
            const stepsContainer = document.createElement('div');
            stepsContainer.className = 'thought-steps';

            // Add each thought step
            currentChainOfThoughts.forEach((thought, index) => {
                const step = document.createElement('div');
                step.className = 'thought-step';
                step.style.opacity = '1'; // Already revealed
                step.style.animation = 'none'; // No animation delay for preserved version

                const stepIcon = document.createElement('div');
                stepIcon.className = 'step-icon';
                stepIcon.textContent = index + 1;

                const stepContent = document.createElement('div');
                stepContent.className = 'step-content';

                const stepTitle = document.createElement('div');
                stepTitle.className = 'step-title';
                stepTitle.textContent = `Step ${index + 1}: ${thought.completed ? 'Completed' : 'Processing'}`;

                const stepResult = document.createElement('div');
                stepResult.className = 'step-result';
                stepResult.textContent = thought.text;

                stepContent.appendChild(stepTitle);
                stepContent.appendChild(stepResult);
                step.appendChild(stepIcon);
                step.appendChild(stepContent);

                stepsContainer.appendChild(step);
            });

            thinkingProcess.appendChild(stepsContainer);
            return thinkingProcess;
        }

        // Complete the previous step when a new one arrives
        function completePreviousStep(chainContainer) {
            if (!chainContainer) return;

            // Find the last processing step (should be the most recent one)
            const processingSteps = chainContainer.querySelectorAll('.chain-item.processing');
            if (processingSteps.length > 0) {
                const lastProcessingStep = processingSteps[processingSteps.length - 1];

                // Mark it as completed
                lastProcessingStep.classList.remove('processing');
                lastProcessingStep.classList.add('completed');

                // Change loader to checkmark
                const loader = lastProcessingStep.querySelector('.chain-loader');
                if (loader) {
                    loader.className = 'chain-check';
                    loader.innerHTML = '';
                }

                // Update timestamp
                // const timestamp = lastProcessingStep.querySelector('.chain-timestamp');
                // if (timestamp) {
                //     timestamp.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                // }

                // Update in global array
                const stepId = lastProcessingStep.dataset.stepId;
                const thoughtIndex = currentChainOfThoughts.findIndex(thought => thought.stepId === stepId);
                if (thoughtIndex >= 0) {
                    currentChainOfThoughts[thoughtIndex].completed = true;
                }

                // Update progress
                updateCOTProgress(chainContainer);
            }
        }

        // Complete all pending steps in the current chain of thoughts
        function completeAllPendingSteps() {
            if (!currentTypingIndicator) return;

            const chainContainer = currentTypingIndicator.querySelector('.chain-container');
            if (!chainContainer) return;

            // Complete all processing steps
            const processingSteps = chainContainer.querySelectorAll('.chain-item.processing');
            processingSteps.forEach(step => {
                step.classList.remove('processing');
                step.classList.add('completed');

                const loader = step.querySelector('.chain-loader');
                if (loader) {
                    loader.className = 'chain-check';
                    loader.innerHTML = '';
                }

                // Update timestamp
                // const timestamp = step.querySelector('.chain-timestamp');
                // if (timestamp) {
                //     timestamp.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                // }
            });

            // Update global array
            currentChainOfThoughts.forEach(thought => {
                if (!thought.completed) {
                    thought.completed = true;
                }
            });

            // Final progress update
            updateCOTProgress(chainContainer);
        }

        // Create Chain of Thoughts UI similar to basic_mpm.html
        function createChainOfThoughtsUI(chainThoughts) {
            if (!chainThoughts || chainThoughts.length === 0) return null;

            const thinkingProcess = document.createElement('div');
            thinkingProcess.className = 'thinking-process';

            // Create thinking header
            const header = document.createElement('div');
            header.className = 'thinking-header';
            header.innerHTML = `
        <div class="thinking-icon"></div>
        <span>Chain of Thoughts - AI Reasoning</span>
    `;
            thinkingProcess.appendChild(header);

            // Create thought steps container
            const thoughtSteps = document.createElement('div');
            thoughtSteps.className = 'thought-steps';

            // Convert chain thoughts to structured steps
            chainThoughts.forEach((thought, index) => {
                const step = document.createElement('div');
                step.className = 'thought-step';
                step.style.animationDelay = `${(index + 1) * 0.1}s`;

                step.innerHTML = `
            <div class="step-icon">${index + 1}</div>
            <div class="step-content">
                <div class="step-title">Processing Step ${index + 1}</div>
                <div class="step-result">${thought.text}</div>
            </div>
        `;

                thoughtSteps.appendChild(step);
            });

            thinkingProcess.appendChild(thoughtSteps);
            return thinkingProcess;
        }

        // ==================== Chat Management Functions ====================
        function generateChatId() {
            return 'chat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function generateChatTitle(firstMessage) {
            if (!firstMessage || typeof firstMessage !== 'string') {
                return generateUniqueTitle('New Chat');
            }

            const cleanMessage = firstMessage.replace(/[^\w\s]/gi, '').trim();
            const words = cleanMessage.split(/\s+/).slice(0, 4);
            let title = words.join(' ');

            if (title.length > 30) {
                title = title.substring(0, 27) + '...';
            }

            const baseTitle = title || 'New Chat';
            return generateUniqueTitle(baseTitle);
        }

        function generateUniqueTitle(baseTitle) {
            const savedChats = getSavedChats();
            const existingTitles = savedChats
                .filter(chat => chat.id !== currentChatId) // Exclude current chat when checking duplicates
                .map(chat => chat.title);

            let uniqueTitle = baseTitle;
            let counter = 1;

            // Keep incrementing counter until we find a unique title
            while (existingTitles.includes(uniqueTitle)) {
                counter++;
                uniqueTitle = `${baseTitle} (${counter})`;
            }

            return uniqueTitle;
        }

        function saveCurrentChatState() {
            if (currentChatData.id) {
                // Save current session state to chat data
                currentChatData.sessionId = sessionId;
                currentChatData.bookingContext = { ...bookingContext };
                currentChatData.currentResponseTag = currentResponseTag;
                currentChatData.followedBy = followedBy;

                // Save scroll position for restoration after refresh
                const scrollPosition = chatMessages.scrollTop;
                currentChatData.scrollPosition = scrollPosition;
            }
        }

        function restoreChatState(chatData) {
            // Restore session state from chat data - each chat maintains its own session
            sessionId = chatData.sessionId || '';
            bookingContext = { ...chatData.bookingContext } || {};
            currentResponseTag = chatData.currentResponseTag || '';
            followedBy = chatData.followedBy || null;

            // Update API headers with this chat's specific session
            API_CONFIG.headers.session = sessionId;

            // Setup socket listener for this chat's session if available
            if (sessionId && socket && socket.connected) {
                setupProcessingListener(sessionId);
            }

            console.log(`Restored chat ${chatData.id} with session: ${sessionId || '(empty - will get new session)'}`);
        }

        function saveCurrentChat() {
            if (!currentChatData.id || currentChatData.messages.length === 0) {
                return;
            }

            // Save current state before storing
            saveCurrentChatState();

            const savedChats = getSavedChats();
            const existingIndex = savedChats.findIndex(chat => chat.id === currentChatData.id);

            currentChatData.lastMessageTime = new Date();

            if (existingIndex !== -1) {
                savedChats[existingIndex] = { ...currentChatData };
            } else {
                savedChats.push({ ...currentChatData });
            }

            // Keep only the latest 50 chats
            if (savedChats.length > 50) {
                savedChats.sort((a, b) => new Date(b.lastMessageTime) - new Date(a.lastMessageTime));
                savedChats.splice(50);
            }

            localStorage.setItem('healthcareChats', JSON.stringify(savedChats));
            renderSavedChats();
        }

        function getSavedChats() {
            const saved = localStorage.getItem('healthcareChats');
            return saved ? JSON.parse(saved) : [];
        }

        function initializeChat() {
            const savedChats = getSavedChats();

            // Check if there's a current chat ID stored (for browser refresh)
            const storedCurrentChatId = localStorage.getItem('currentChatId');

            if (storedCurrentChatId && savedChats.length > 0) {
                // Try to load the previously active chat after refresh
                const previousChat = savedChats.find(chat => chat.id === storedCurrentChatId);

                if (previousChat) {
                    console.log(` Restoring chat ${storedCurrentChatId} after browser refresh`);
                    loadChatData(previousChat);
                } else {
                    // If the stored chat doesn't exist, load most recent
                    const mostRecentChat = savedChats.sort((a, b) =>
                        new Date(b.lastMessageTime) - new Date(a.lastMessageTime)
                    )[0];
                    loadChatData(mostRecentChat);
                }
            } else if (savedChats.length > 0) {
                // Load the most recent chat if no stored current chat
                const mostRecentChat = savedChats.sort((a, b) =>
                    new Date(b.lastMessageTime) - new Date(a.lastMessageTime)
                )[0];
                loadChatData(mostRecentChat);
            } else {
                // Only create new chat if no chats exist
                createInitialChat();
            }

            // Update sidebar
            renderSavedChats();
        }

        function loadChatData(chatData) {
            // Set current chat data
            currentChatData = { ...chatData };
            currentChatId = chatData.id;

            // Store current chat ID for browser refresh recovery
            localStorage.setItem('currentChatId', chatData.id);
            console.log(` Stored current chat ID: ${chatData.id}`);

            // Clear Chain of Thoughts when switching chats
            clearChainOfThoughts();

            // Restore COT storage for this chat
            if (chatData.cotData) {
                cotStorage = { ...chatData.cotData };
                console.log(` Loaded ${Object.keys(cotStorage).length} COT entries for chat ${chatData.id}`);
            } else {
                cotStorage = {};
            }

            // Restore session state
            restoreChatState(chatData);

            // Update localStorage and API headers with the chat's session
            if (chatData.sessionId) {
                localStorage.setItem("chatSession", chatData.sessionId);
                API_CONFIG.headers.session = chatData.sessionId;

                // Setup socket listener for this session
                if (socket && socket.connected) {
                    setupProcessingListener(chatData.sessionId);
                }
            }

            // Clear messages area
            chatMessages.innerHTML = '';
            console.log(" Cleared chat messages area for chat", chatData);

            // Recreate ALL messages with their original UI including interactive elements
            console.log(` Loading ${chatData.messages.length} messages for chat ${chatData.id}`);
            chatData.messages.forEach((message, index) => {
                console.log(`Message ${index}:`, message.type, message);

                if (message.type === 'text') {
                    // Regular text message - check if it has COT data via message ID
                    const messageCOT = message.hasCOT && message.cotId ? cotStorage[message.cotId] : null;

                    if (messageCOT && messageCOT.length > 0) {
                        // Recreate message with COT from storage
                        addMessageWithStoredCOT(chatData.response, message.content, message.isUser, messageCOT, message.id || message.cotId);
                    } else {
                        // Regular message without COT
                        addMessageToDOM(message.content, message.isUser);
                    }
                }
                else if (message.type === 'selection') {
                    // Recreate selection options with full UI
                    console.log(' Recreating selection message');
                    recreateSelectionOptions(message);
                }
                else if (message.type === 'confirmation') {
                    // Recreate confirmation dialog with full UI
                    console.log(' Recreating confirmation message');
                    recreateConfirmationDialog(message);
                }
                else if (message.type === 'success') {
                    // Recreate success card with full UI
                    console.log(' Recreating success message');
                    recreateBookingSuccess(message);
                }
            });

            // Scroll to bottom
            chatMessages.scrollTop = chatMessages.scrollHeight;

            // Restore scroll position if this is the same chat being reloaded (e.g., after refresh)
            if (chatData.scrollPosition !== undefined && chatData.scrollPosition > 0) {
                setTimeout(() => {
                    chatMessages.scrollTop = chatData.scrollPosition;
                    console.log(` Restored scroll position: ${chatData.scrollPosition}`);
                }, 100);
            }
        }

        // Function to add a message with stored COT data
        function addMessageWithStoredCOT(response, content, isUser, storedCOT, messageId) {
            // Fix: Use correct COT step field and show stored response
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'bot'}`;
            messageDiv.dataset.messageId = messageId;

            // Create avatar
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = isUser ? '' : 'HA';
            messageDiv.appendChild(avatar);

            // Create message content
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';

            try {
                if (isUser) {
                    messageContent.innerHTML = parseMarkdownContent(content);
                } else {
                    // Unified panel for bot with COT and response
                    const unifiedPanel = document.createElement('div');
                    unifiedPanel.className = 'unified-cot-response-panel';

                    // Chain of Thoughts section
                    const cotSection = document.createElement('div');
                    cotSection.className = 'chain-container';
                    cotSection.dataset.messageId = messageId;
                    cotSection.style.display = 'flex !important';

                    storedCOT.forEach((thought, index) => {
                        const stepDiv = document.createElement('div');
                        stepDiv.className = `chain-item ${thought.completed ? 'completed' : 'processing'}`;
                        stepDiv.dataset.stepId = thought.stepId || `step_${index}`;

                        const iconDiv = document.createElement('div');
                        iconDiv.className = thought.completed ? 'chain-check' : 'chain-loader';
                        if (thought.completed) iconDiv.innerHTML = '';

                        const textContent = document.createElement('div');
                        textContent.style.flex = '1';

                        // Fix: Use only the correct COT field (not .content)
                        const textElement = document.createElement('div');
                        textElement.className = 'chain-text';
                        textElement.textContent = thought.thought || thought.message || thought.text || 'Processing step ' + (index + 1);

                        textContent.appendChild(textElement);
                        stepDiv.appendChild(iconDiv);
                        stepDiv.appendChild(textContent);
                        cotSection.appendChild(stepDiv);
                    });

                    unifiedPanel.appendChild(cotSection);

                    // Separator
                    const separator = document.createElement('div');
                    separator.className = 'cot-response-separator';
                    separator.innerHTML = '<div class="separator-line"></div><div class="separator-label">AI Response</div><div class="separator-line"></div>';
                    unifiedPanel.appendChild(separator);

                    // Show the stored response (not just content)
                    const responseContent = document.createElement('div');
                    responseContent.className = 'bot-response-content';
                    responseContent.innerHTML = parseMarkdownContent(response || content);
                    unifiedPanel.appendChild(responseContent);

                    messageContent.appendChild(unifiedPanel);
                }

                messageDiv.appendChild(messageContent);
                chatMessages.appendChild(messageDiv);

                // Animation
                messageDiv.style.opacity = '0';
                messageDiv.style.transform = isUser ? 'translateX(20px)' : 'translateX(-20px)';
                messageDiv.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
                setTimeout(() => {
                    messageDiv.style.opacity = '1';
                    messageDiv.style.transform = 'translateX(0)';
                }, 10);
                return messageDiv;
            } catch (error) {
                console.error('Error adding message with COT:', error);
                messageContent.textContent = response || content;
                messageDiv.appendChild(messageContent);
                chatMessages.appendChild(messageDiv);
                return messageDiv;
            }
        }

        // Function to recreate selection options from saved data
        function recreateSelectionOptions(messageData) {
            console.log(' Recreating selection options:', messageData);

            const { options, message, optionType, shouldUseContinueAPI } = messageData;

            // Validate that we have the necessary data
            if (!options || !Array.isArray(options)) {
                console.error(' Invalid options data:', messageData);
                return;
            }

            // Use the renderSelectionOptions function to recreate the exact same UI
            // But make the cards non-interactive (read-only) since this is historical data
            renderSelectionOptionsReadOnly(options, message, optionType || 'Option');
        }

        // Read-only version of renderSelectionOptions for historical chats
        function renderSelectionOptionsReadOnly(options, message = '', type = 'Option') {
            console.log(' Recreating selection optionsssssssssssss:', options);
            console.log(' message:', message);

            message = options.content;
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message bot';

            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = 'HA';
            messageDiv.appendChild(avatar);

            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';

            if (message) {
                const textDiv = document.createElement('div');
                textDiv.innerHTML = parseMarkdownContent(message);
                textDiv.style.marginBottom = '15px';
                messageContent.appendChild(textDiv);
            }

            // Check if this is employee data
            const isEmployeeData = options?.response?.length > 0 && typeof options.response[0] === 'object' &&
                (options.response[0].EmployeeId || options.response[0].EmployeeFullName || options.response[0].match_score !== undefined);

            let optionsSection;
            if (isEmployeeData) {
                optionsSection = document.createElement('div');
                optionsSection.className = 'employee-cards-section';

                const title = document.createElement('div');
                title.className = 'section-title';
                title.innerHTML = ` Available Healthcare Providers:`;
                messageContent.appendChild(title);
            } else {
                optionsSection = document.createElement('div');
                optionsSection.className = 'cards-section scrollable-row';

                const title = document.createElement('div');
                title.className = 'section-title';
                title.innerHTML = `${getTypeIcon(type)} Available ${type}s:`;
                messageContent.appendChild(title);
            }

            const colors = ['#fa9d9d', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#FFB6C1', '#98FB98'];
            console.log('asdasdsd', options);

            options.response.forEach((optionValue, index) => {

                let optionCard, optionName, optionSubtext;

                // Check if this is employee data
                if (isEmployeeData && typeof optionValue === 'object' && optionValue.EmployeeId) {
                    // Create employee card
                    optionCard = createEmployeeCard(optionValue, index);
                    optionName = optionValue.EmployeeFullName;
                } else {
                    // Create regular option card
                    optionCard = document.createElement('div');
                    optionCard.className = 'option-card square-card';

                    const color = colors[index % colors.length];

                    if (typeof optionValue === 'string') {
                        optionName = optionValue;
                        optionSubtext = getTypeSubtitle(type, optionValue);
                    } else if (typeof optionValue === 'object' && optionValue !== null) {
                        optionName = optionValue.name || optionValue.value || optionValue.title || optionValue.label ||
                            optionValue.doctor_name || optionValue.client_name || optionValue.patient_name ||
                            optionValue.location_name || optionValue.service_name || optionValue.time_slot ||
                            optionValue.slot || optionValue.date || optionValue.appointment_date || optionValue.text || 'Option';

                        optionSubtext = optionValue.subtitle || optionValue.description || optionValue.specialty ||
                            optionValue.details || optionValue.info || optionValue.room || optionValue.duration ||
                            optionValue.availability || getTypeSubtitle(type, optionName);
                    } else {
                        optionName = String(optionValue);
                        optionSubtext = getTypeSubtitle(type, optionName);
                    }

                    // Always split optionName by '|' and render in a column
                    let optionNameHtml = '';
                    if (optionName) {
                        const displayName = formatOptionName(optionName);
                        const parts = displayName.split('=>').map(s => s.trim());
                        if (parts.length > 1) {
                            optionNameHtml = `<ul class="option-name option-list-card" title="${displayName}">` +
                                parts.map(part => `<li class="option-list-item">${part}</li>`).join('') +
                                `</ul>`;
                        } else {
                            optionNameHtml = `<div class="option-name option-single-card" title="${displayName}">${displayName}</div>`;
                        }
                    }

                    optionCard.innerHTML = `
                        <div class="avatar" style="background: linear-gradient(135deg, ${color}, ${color}CC)">
                            ${getTypeIcon(type)}
                        </div>
                        <div class="option-info option-info-card">
                            ${optionNameHtml}
                            <div class="option-subtitle option-subtitle-card" title="${optionSubtext}">${optionSubtext}</div>
                        </div>
                    `;
                }


                // Make cards non-interactive for historical chats (no click handlers)
                optionCard.style.cursor = 'default';
                optionCard.style.opacity = '0.9';
                /* Add styles for square card and column stack */

                optionsSection.appendChild(optionCard);
            });

            messageContent.appendChild(optionsSection);
            messageDiv.appendChild(messageContent);
            chatMessages.appendChild(messageDiv);
        }

        // Create initial chat (only called when no chats exist)
        function createInitialChat() {
            currentChatData = {
                id: generateChatId(),
                title: 'New Chat',
                messages: [],
                createdAt: new Date(),
                lastMessageTime: new Date(),
                sessionId: '', // Start with empty session for new chat
                bookingContext: {},
                currentResponseTag: '',
                followedBy: null,
                cotData: {} // Initialize empty COT data
            };

            currentChatId = currentChatData.id;

            // Store new chat ID for browser refresh recovery
            localStorage.setItem('currentChatId', currentChatData.id);

            // Clear chat messages
            chatMessages.innerHTML = '';

            // Reset session and context - ensure fresh session for new chat
            sessionId = '';
            localStorage.removeItem("chatSession");
            initializeSession();
            bookingContext = {};
            currentResponseTag = '';
            followedBy = null;

            // Clear COT storage
            cotStorage = {};

            // Show welcome message

        }

        // Create new chat when user clicks button
        function createNewChat() {
            // Save current chat before creating new one
            saveCurrentChat();

            // Reset current chat data - each new chat gets fresh session
            currentChatData = {
                id: generateChatId(),
                title: 'New Chat',
                messages: [],
                createdAt: new Date(),
                lastMessageTime: new Date(),
                sessionId: '', // Start with empty session for completely new conversation
                bookingContext: {},
                currentResponseTag: '',
                followedBy: null,
                cotData: {} // Initialize empty COT data
            };

            currentChatId = currentChatData.id;

            // Store new chat ID for browser refresh recovery
            localStorage.setItem('currentChatId', currentChatData.id);

            // Clear chat messages
            chatMessages.innerHTML = '';

            // Reset session and context - ensure new chat gets fresh session
            sessionId = '';
            localStorage.removeItem("chatSession");
            initializeSession()
            bookingContext = {};
            currentResponseTag = '';
            followedBy = null;

            // Clear Chain of Thoughts for new chat
            clearChainOfThoughts();

            // Clear COT storage
            cotStorage = {};

            // Clear API config session to ensure fresh start
            API_CONFIG.headers.session = '';

            // Show welcome message


            // Update active chat in sidebar
            renderSavedChats();

            // Focus input
            messageInput.focus();
        }

        function loadChat(chatId) {
            // Don't reload the same chat
            if (currentChatId === chatId) {
                return;
            }

            // Save current chat first
            saveCurrentChat();

            const savedChats = getSavedChats();
            const chatToLoad = savedChats.find(chat => chat.id === chatId);

            if (!chatToLoad) {
                console.error('Chat not found:', chatId);
                return;
            }

            // Load the chat data
            loadChatData(chatToLoad);

            // Update active chat in sidebar
            renderSavedChats();
        }

        function deleteChat(chatId, event) {
            event.preventDefault();
            event.stopPropagation();

            if (!confirm('Are you sure you want to delete this chat?')) {
                return;
            }

            let savedChats = getSavedChats();
            savedChats = savedChats.filter(chat => chat.id !== chatId);
            localStorage.setItem('healthcareChats', JSON.stringify(savedChats));

            // If we're deleting the current chat
            if (currentChatId === chatId) {
                // Remove current chat ID from localStorage
                localStorage.removeItem('currentChatId');

                // Check if there are other chats
                if (savedChats.length > 0) {
                    // Load the most recent chat
                    const mostRecentChat = savedChats.sort((a, b) =>
                        new Date(b.lastMessageTime) - new Date(a.lastMessageTime)
                    )[0];
                    loadChat(mostRecentChat.id);
                } else {
                    // Create new chat if no chats exist
                    createInitialChat();
                }
            }

            renderSavedChats();
        }

        function renderSavedChats() {
            const savedChats = getSavedChats();
            savedChats.sort((a, b) => new Date(b.lastMessageTime) - new Date(a.lastMessageTime));

            if (savedChats.length === 0) {
                savedChatsList.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"></div>
                <div class="empty-state-text">No saved chats yet</div>
                <div class="empty-state-subtext">Start a new conversation</div>
            </div>
        `;
                return;
            }

            savedChatsList.innerHTML = savedChats.map(chat => {
                const isActive = chat.id === currentChatId;
                const textMessages = chat.messages.filter(msg => msg.type === 'text' && msg.isUser);
                const lastUserMessage = textMessages.length > 0 ? textMessages[textMessages.length - 1] : null;
                const preview = lastUserMessage ?
                    (lastUserMessage.content.length > 50 ? lastUserMessage.content.substring(0, 47) + '...' : lastUserMessage.content) :
                    'New conversation';

                const timeStr = formatChatTime(new Date(chat.lastMessageTime));

                return `
            <div class="chat-item ${isActive ? 'active' : ''}" onclick="loadChat('${chat.id}')">
                <div class="chat-item-title">${chat.title}</div>
                <div class="chat-item-time">${timeStr}</div>
                <button class="chat-item-delete" onclick="deleteChat('${chat.id}', event)"></button>
            </div>
        `;
                //                 return `
                //     <div class="chat-item ${isActive ? 'active' : ''}" onclick="loadChat('${chat.id}')">
                //         <div class="chat-item-title">${chat.title}</div>
                //         <div class="chat-item-preview">${preview}</div>
                //         <div class="chat-item-time">${timeStr}</div>
                //         <button class="chat-item-delete" onclick="deleteChat('${chat.id}', event)"></button>
                //     </div>
                // `;
            }).join('');
        }

        function formatChatTime(date) {
            const now = new Date();
            const diffInHours = (now - date) / (1000 * 60 * 60);

            if (diffInHours < 1) {
                return 'Just now';
            } else if (diffInHours < 24) {
                return `${Math.floor(diffInHours)}h ago`;
            } else if (diffInHours < 24 * 7) {
                return `${Math.floor(diffInHours / 24)}d ago`;
            } else {
                return date.toLocaleDateString();
            }
        }

        // ==================== Message Handling Functions ====================
        function addMessageToCurrentChat(content, isUser = false, type = 'text', additionalData = {}) {
            // Ensure we have a chat to add messages to
            if (!currentChatData.id) {
                currentChatData.id = generateChatId();
                currentChatId = currentChatData.id;
            }

            // Generate title from first user message
            if (isUser && currentChatData.messages.filter(msg => msg.isUser && msg.type === 'text').length === 0 && type === 'text') {
                currentChatData.title = generateChatTitle(content);
            }

            // Generate unique message ID
            const messageId = generateMessageId();

            // Add message to current chat data with type information
            const messageData = {
                id: messageId,
                type: type,
                content: content,
                isUser: isUser,
                timestamp: new Date(),
                ...additionalData
            };

            // If this is a bot message and we have COT data, store it separately by message ID
            if (!isUser && type === 'text' && currentChainOfThoughts.length > 0) {
                if (!currentChatData.cotData) {
                    currentChatData.cotData = {};
                }
                currentChatData.cotData[messageId] = [...currentChainOfThoughts];
                // Store the last emitted response for this message
                if (typeof additionalData.response === 'string') {
                    currentChatData.cotData[messageId].response = additionalData.response;
                }
                updateHeaderToComplete();
                cotStorage[messageId] = [...currentChainOfThoughts];
                if (typeof additionalData.response === 'string') {
                    cotStorage[messageId].response = additionalData.response;
                }
                messageData.hasCOT = true;
                messageData.cotId = messageId;
            }

            // Store the emitted response in the messageData for retrieval
            if (typeof additionalData.response === 'string') {
                messageData.response = additionalData.response;
            }

            currentChatData.messages.push(messageData);
            currentChatData.lastMessageTime = new Date();
            saveCurrentChat();
            return messageId;
        }

        // Utility function to sanitize HTML while preserving markdown formatting
        function sanitizeHTML(html) {
            const div = document.createElement('div');
            div.innerHTML = html;

            // Remove script tags and other potentially dangerous elements
            const scripts = div.querySelectorAll('script, object, embed, iframe');
            scripts.forEach(script => script.remove());

            // Remove event handlers
            const allElements = div.querySelectorAll('*');
            allElements.forEach(el => {
                const attributes = [...el.attributes];
                attributes.forEach(attr => {
                    if (attr.name.startsWith('on')) {
                        el.removeAttribute(attr.name);
                    }
                });
            });

            return div.innerHTML;
        }

        // Enhanced function to parse and render markdown content with better formatting
        function parseMarkdownContent(content) {
            try {
                // Pre-process content for better markdown rendering
                let processedContent = content;

                // Ensure proper line breaks for lists and sections
                processedContent = processedContent?.replace(/\n\n/g, '\n\n');

                // Parse the markdown using marked library
                let parsed = marked.parse(processedContent);

                // Sanitize the HTML to prevent XSS
                parsed = sanitizeHTML(parsed);

                // Apply syntax highlighting to code blocks
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = parsed;

                const codeBlocks = tempDiv.querySelectorAll('pre code');
                codeBlocks.forEach(block => {
                    hljs.highlightElement(block);
                    const pre = block.parentElement;
                    if (pre && !pre.parentElement.classList.contains('markdown-code-block')) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'markdown-code-block';
                        const toolbar = document.createElement('div');
                        toolbar.className = 'markdown-code-toolbar';
                        const btn = document.createElement('button');
                        btn.className = 'copy-code-btn';
                        btn.type = 'button';
                        btn.textContent = ' Copy';
                        btn.onclick = function () { window.copyCodeToClipboard(btn); };
                        toolbar.appendChild(btn);
                        pre.parentNode.insertBefore(wrapper, pre);
                        wrapper.appendChild(pre);
                        wrapper.appendChild(toolbar);
                    }
                });

                // Style lists and other elements for better appearance
                const lists = tempDiv.querySelectorAll('ul, ol');
                lists.forEach(list => {
                    list.style.marginLeft = '20px';
                    list.style.marginBottom = '10px';
                });

                const paragraphs = tempDiv.querySelectorAll('p');
                paragraphs.forEach(p => {
                    p.style.marginBottom = '8px';
                    p.style.lineHeight = '1.4';
                });

                const emphasis = tempDiv.querySelectorAll('em');
                emphasis.forEach(em => {
                    em.style.color = '#666';
                    em.style.fontSize = '0.9em';
                });

                const strong = tempDiv.querySelectorAll('strong');
                strong.forEach(s => {
                    s.style.fontWeight = 'bold';
                });

                return tempDiv.innerHTML;
            } catch (error) {
                console.error('Error parsing markdown:', error);
                // Fallback to simple HTML escaping and basic formatting
                return content
                    .replace(/\n/g, '<br>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code>$1</code>');
            }
        }


        function showTypingIndicator() {
            // Reset any ongoing chain of thoughts
            currentChainOfThoughts = [];

            // Main typing message container
            const typingDiv = document.createElement('div');
            typingDiv.className = 'message bot';
            typingDiv.id = 'typingIndicator';

            // Create message content wrapper
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';

            // Create typing indicator
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'typing-indicator';
            typingIndicator.setAttribute('role', 'status');
            typingIndicator.setAttribute('aria-live', 'polite');
            typingIndicator.setAttribute('aria-atomic', 'true');

            // --- Typing Header ---
            const typingHeader = document.createElement('div');
            typingHeader.className = 'typing-header';

            const mainContent = document.createElement('div');
            mainContent.className = 'typing-main-content';

            const typingText = document.createElement('span');
            typingText.className = 'typing-main-text';
            typingText.id = 'typingText';
            typingText.textContent = 'AI processing your request';

            const typingDots = document.createElement('div');
            typingDots.className = 'typing-dots';
            typingDots.setAttribute('aria-hidden', 'true');
            typingDots.innerHTML = `
      <span class="typing-dot">.</span>
      <span class="typing-dot">.</span>
      <span class="typing-dot">.</span>
  `;

            mainContent.appendChild(typingText);
            typingHeader.appendChild(mainContent);
            typingHeader.appendChild(typingDots);
            typingIndicator.appendChild(typingHeader);

            // --- Chain of Thought Section ---
            const cotSection = document.createElement('div');
            cotSection.className = 'cot-section collapsed';

            const cotHeader = document.createElement('div');
            cotHeader.className = 'cot-header';

            const headerContent = document.createElement('div');
            headerContent.className = 'header-content';
            headerContent.innerHTML = `
      <div class="header-loading">
          <div class="chain-loader"></div>
          <div class="chain-text">Analyzing</div>
      </div>
  `;

            const toggleIcon = document.createElement('span');
            toggleIcon.className = 'toggle-icon';
            toggleIcon.textContent = '';

            cotHeader.appendChild(headerContent);
            cotHeader.appendChild(toggleIcon);

            const chainContainer = document.createElement('div');
            chainContainer.className = 'chain-container';

            // // Initial loading item
            //   const loadingItem = document.createElement('div');
            //   loadingItem.className = 'chain-item processing';
            //   loadingItem.innerHTML = `
            //       <div class="chain-loader"></div>
            //       <div class="chain-text">Analyzing</div>
            //   `;
            //   chainContainer.appendChild(loadingItem);

            cotSection.appendChild(cotHeader);
            cotSection.appendChild(chainContainer);

            // Store references for later updates
            currentChainContainer = chainContainer;

            // --- Expand/Collapse Logic ---
            let isExpanded = false;
            cotHeader.addEventListener('click', () => {
                isExpanded = !isExpanded;
                cotSection.classList.toggle('expanded', isExpanded);
                cotSection.classList.toggle('collapsed', !isExpanded);

                if (isExpanded) {
                    chainContainer.style.maxHeight = chainContainer.scrollHeight + 'px';
                    setTimeout(() => (chainContainer.style.maxHeight = 'none'), 300);
                } else {
                    // show truncated latest COT in preview when collapsed
                    const latest = currentChainOfThoughts && currentChainOfThoughts.length > 0 ? currentChainOfThoughts[currentChainOfThoughts.length - 1].text : null;

                    chainContainer.style.maxHeight = chainContainer.scrollHeight + 'px';
                    void chainContainer.offsetHeight; // Force reflow
                    chainContainer.style.maxHeight = '0';
                }
            });

            // // Auto-expand after a short delay
            // setTimeout(() => {
            //     isExpanded = true;
            //     cotSection.classList.add('expanded');
            //     cotSection.classList.remove('collapsed');
            //     chainContainer.style.maxHeight = chainContainer.scrollHeight + 'px';
            // }, 500);

            // --- Assemble all parts ---
            messageContent.appendChild(typingIndicator);
            messageContent.appendChild(cotSection);

            typingDiv.innerHTML = '<div class="message-avatar">HA</div>';
            typingDiv.appendChild(messageContent);

            // Append to chat container
            const messagesContainer = document.getElementById('chatMessages');
            if (messagesContainer) {
                messagesContainer.appendChild(typingDiv);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            // Keep reference to typing indicator for later updates
            typingDiv.chainContainer = chainContainer;
            currentTypingIndicator = typingDiv;

            // // Set initial text state
            // if (typeof updateTypingIndicatorText === 'function') {
            //     updateTypingIndicatorText({ message: 'Analyzing' });
            // }

            return typingDiv;
        }

        function removeTypingIndicator() {
            // Complete all pending steps before removing the typing indicator
            completeAllPendingSteps();

            const typingIndicator = document.getElementById('typingIndicator');
            if (typingIndicator) {
                // Hide the typing dots and main text, but keep the COT container visible
                const typingDotsElement = typingIndicator.querySelector('.typing-dots');
                const typingMainTextElement = typingIndicator.querySelector('.typing-main-text');

                if (typingDotsElement) {
                    typingDotsElement.style.display = 'none';
                }
                if (typingMainTextElement) {
                    typingMainTextElement.style.display = 'none';
                }

                // Remove the typing indicator ID but keep the element as a regular message
                typingIndicator.removeAttribute('id');
            }

            // Clear the current typing indicator reference
            currentTypingIndicator = null;
            try { sendBtn.disabled = false; } catch (e) { }

            // Clean up socket listener if needed
            if (socket && sessionId) {
                // ensure we remove the same event used when registering (with underscore)
                const eventProcess = `${sessionId}_process`;
                socket.off(eventProcess);
            }

            // Note: We don't clear currentChainOfThoughts here to preserve it for the final message
        }
        function renderMessages(messages) {
            const container = document.getElementById("chatMessages");
            container.innerHTML = '';

            messages.forEach(msg => {
                addMessageToDOM(msg.content, msg.role === "user");
            });

            container.scrollTop = container.scrollHeight;
        }
        function addMessageToDOM(content, isUser = false, includeChainOfThoughts = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'bot'}`;

            // Create avatar
            const avatar = document.createElement('div');
            avatar.className = 'message-avatar';
            avatar.textContent = isUser ? '' : 'HA';
            messageDiv.appendChild(avatar);

            // Create message content
            const messageContent = document.createElement('div');
            messageContent.className = 'message-content';

            try {
                if (isUser) {
                    // For user messages, parse markdown content
                    messageContent.innerHTML = parseMarkdownContent(content);
                } else {
                    // For bot messages, create unified COT-Response panel if COT is available
                    if (includeChainOfThoughts && currentChainOfThoughts.length > 0) {
                        // Create unified panel structure
                        const unifiedPanel = document.createElement('div');
                        unifiedPanel.className = 'unified-cot-response-panel';

                        // Create header
                        const header = document.createElement('div');
                        header.className = 'unified-panel-header';

                        const headerText = document.createElement('div');
                        headerText.className = 'unified-panel-header-text';
                        headerText.textContent = 'AI Reasoning Process';

                        const toggleButton = document.createElement('button');
                        toggleButton.className = 'unified-panel-toggle';
                        toggleButton.innerHTML = '';
                        toggleButton.setAttribute('aria-label', 'Toggle reasoning process');
                        toggleButton.setAttribute('aria-expanded', 'true');

                        header.appendChild(headerText);
                        header.appendChild(toggleButton);
                        unifiedPanel.appendChild(header);

                        // Add Chain of Thoughts section
                        const cotSection = document.createElement('div');
                        cotSection.className = 'chain-container';

                        currentChainOfThoughts.forEach(thought => {
                            const stepDiv = document.createElement('div');
                            stepDiv.className = `chain-item ${thought.completed ? 'completed' : 'processing'}`;
                            stepDiv.innerHTML = `
                        <div class="${thought.completed ? 'chain-check' : 'chain-loader'}">
                            ${thought.completed ? '' : ''}
                        </div>
                        <div class="chain-text">${thought.message}</div>
                    `;
                            cotSection.appendChild(stepDiv);
                        });

                        // Add response content
                        const responseContent = document.createElement('div');
                        responseContent.className = 'bot-response-content';
                        responseContent.innerHTML = parseMarkdownContent(content);

                        // Add toggle functionality
                        let isExpanded = true;
                        function togglePanel() {
                            isExpanded = !isExpanded;
                            cotSection.style.maxHeight = isExpanded ? `${cotSection.scrollHeight}px` : '0';
                            toggleButton.textContent = isExpanded ? '' : '';
                            toggleButton.setAttribute('aria-expanded', isExpanded);
                            unifiedPanel.classList.toggle('collapsed', !isExpanded);
                        }

                        header.addEventListener('click', togglePanel);
                        toggleButton.addEventListener('click', (e) => e.stopPropagation());

                        // Initially collapse the panel
                        togglePanel();

                        unifiedPanel.insertBefore(cotSection, unifiedPanel.firstChild.nextSibling);
                        messageContent.appendChild(unifiedPanel);
                        messageContent.appendChild(responseContent);
                    } else {
                        // Regular bot message without COT
                        const responseContent = document.createElement('div');
                        responseContent.innerHTML = parseMarkdownContent(content);
                        messageContent.appendChild(responseContent);
                    }

                    // Process any markdown tables for better display
                    const tables = messageContent.querySelectorAll('table');
                    tables.forEach(table => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'markdown-table-wrapper';
                        table.parentNode.insertBefore(wrapper, table);
                        wrapper.appendChild(table);
                    });
                }

                messageDiv.appendChild(messageContent);
                chatMessages.appendChild(messageDiv);

                // Add animation
                messageDiv.style.opacity = '0';
                messageDiv.style.transform = isUser ? 'translateX(20px)' : 'translateX(-20px)';
                messageDiv.style.transition = 'opacity 0.3s ease, transform 0.3s ease';

                // Trigger animation
                setTimeout(() => {
                    messageDiv.style.opacity = '1';
                    messageDiv.style.transform = 'translateX(0)';
                }, 10);

                // Scroll to show the new message
                chatMessages.scrollTop = chatMessages.scrollHeight;

                return messageDiv;
            } catch (error) {
                console.error('Error adding message:', error);
                // Fallback for any parsing errors
                messageContent.textContent = content;
                messageDiv.appendChild(messageContent);
                chatMessages.appendChild(messageDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                return messageDiv;
            }
        }

        function updateHeaderToComplete() {
            const headerLoading = document.querySelector('.header-loading');
            if (headerLoading) {
                headerLoading.innerHTML = `
            <div class="chain-check"></div>
            <div class="chain-text">Analysis complete</div>
        `;
                headerLoading.classList.add('completed');
            }
        }



        function addMessage(content, isUser = false, includeChainOfThoughts = false) {
            // Only show COT if explicitly requested or if there are actual COT steps from live processing
            const hasLiveCOT = !isUser && currentTypingIndicator && currentTypingIndicator.querySelector('.chain-container')?.children.length > 0;

            // Check if there's an existing typing indicator with live COT that can be converted to a regular message
            const existingTypingIndicator = document.querySelector('.message.bot:not([id])');
            const existingChainContainer = existingTypingIndicator?.querySelector('.chain-container');

            if (hasLiveCOT && existingChainContainer && existingChainContainer.children.length > 0) {
                // Convert existing typing indicator to unified COT + Response panel
                const typingIndicatorContent = existingTypingIndicator.querySelector('.typing-indicator');
                if (typingIndicatorContent) {
                    // Transform the typing indicator into a unified COT-Response panel
                    typingIndicatorContent.className = 'unified-cot-response-panel';

                    // Add a separator between COT and response
                    const separator = document.createElement('div');
                    separator.className = 'cot-response-separator';
                    separator.innerHTML = '<div class="separator-line"></div><div class="separator-label">AI Response</div><div class="separator-line"></div>';
                    typingIndicatorContent.appendChild(separator);

                    // Add the main bot response content
                    const responseContent = document.createElement('div');
                    responseContent.className = 'bot-response-content';
                    responseContent.innerHTML = parseMarkdownContent(content);
                    typingIndicatorContent.appendChild(responseContent);

                    // Scroll to show the new content
                    chatMessages.scrollTop = chatMessages.scrollHeight;

                    // Add to current chat data
                    addMessageToCurrentChat(content, isUser);
                    return;
                }
            }

            // Add to DOM normally - only include COT if explicitly requested or if it was part of live processing
            const shouldIncludeCOT = includeChainOfThoughts || hasLiveCOT;
            addMessageToDOM(content, isUser, shouldIncludeCOT);
            // Add to current chat data
            addMessageToCurrentChat(content, isUser);

            // Clear COT after using it to avoid showing it in subsequent messages
            if (!isUser && !includeChainOfThoughts) {
                currentChainOfThoughts = [];
            }
        }

        // Helper function to update an existing message in the chat history
        function updateMessageInChatHistory(messageId, additionalContent, isAppend = false) {
            const chatData = getCurrentChatData();
            if (!chatData) return;

            const message = chatData.messages.find(msg => msg.id === messageId);
            if (message) {
                if (isAppend) {
                    // Append to existing content
                    message.content += `\n\n${additionalContent}`;
                } else {
                    // Update content
                    message.content = additionalContent;
                }
                saveCurrentChat();
            }
        }
        // Generate booking ID
        function generateBookingId() {
            return 'BK' + Date.now().toString().slice(-6);
        }

        // Clear Chain of Thoughts when starting new chat
        function clearChainOfThoughts() {
            currentChainOfThoughts = [];
            currentMessageId = null;
        }

        // Get COT data for a specific message ID
        function getCOTForMessage(messageId) {
            return cotStorage[messageId] || (currentChatData.cotData && currentChatData.cotData[messageId]) || null;
        }

        // Store COT data for a specific message ID
        function storeCOTForMessage(messageId, cotData) {
            if (!currentChatData.cotData) {
                currentChatData.cotData = {};
            }
            currentChatData.cotData[messageId] = cotData;
            cotStorage[messageId] = cotData;
            console.log(` Stored COT for message ${messageId}:`, cotData);
        }

        // Delete COT data for a specific message ID
        function deleteCOTForMessage(messageId) {
            if (cotStorage[messageId]) {
                delete cotStorage[messageId];
            }
            if (currentChatData.cotData && currentChatData.cotData[messageId]) {
                delete currentChatData.cotData[messageId];
            }
            console.log(` Deleted COT for message ${messageId}`);
        }

        // Get all COT data for current chat
        function getAllCOTForChat() {
            return currentChatData.cotData || {};
        }

        // Export COT data statistics
        function getCOTStatistics() {
            const totalMessages = currentChatData.messages.length;
            const messagesWithCOT = currentChatData.messages.filter(m => m.hasCOT).length;
            const totalCOTSteps = Object.values(cotStorage).reduce((sum, cot) => sum + cot.length, 0);

            return {
                chatId: currentChatData.id,
                totalMessages,
                messagesWithCOT,
                totalCOTSteps,
                cotStorageSize: Object.keys(cotStorage).length,
                averageStepsPerMessage: messagesWithCOT > 0 ? (totalCOTSteps / messagesWithCOT).toFixed(2) : 0
            };
        }

        // Clean up stale data on browser refresh
        function cleanupStaleData() {
            // Remove any orphaned currentChatId if the chat doesn't exist
            const storedChatId = localStorage.getItem('currentChatId');
            if (storedChatId) {
                const savedChats = getSavedChats();
                const chatExists = savedChats.some(chat => chat.id === storedChatId);

                if (!chatExists) {
                    console.log(` Removing stale chat ID: ${storedChatId}`);
                    localStorage.removeItem('currentChatId');
                }
            }
        }

        // Display refresh notification (optional visual feedback)
        function showRefreshNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 12px 20px;
                border-radius: 12px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
                z-index: 10000;
                font-size: 14px;
                font-weight: 600;
                opacity: 0;
                transition: opacity 0.3s ease;
                display: flex;
                align-items: center;
                gap: 10px;
            `;
            notification.innerHTML = ' <span>Chat restored after refresh</span>';
            document.body.appendChild(notification);

            // Fade in
            setTimeout(() => notification.style.opacity = '1', 100);

            // Fade out and remove
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // ==================== API Functions ====================
        async function makeAPICall(message) {
            try {
                // Build headers from API_CONFIG and prefer per-chat session if available
                const headers = Object.assign({}, API_CONFIG.headers || {});
                console.log(headers);
                if (headers.session == '' || headers.session == null || headers.session == undefined) {
                    headers.session = localStorage.getItem('chatSession') || '';
                }
                // Determine effective session: per-chat -> global sessionId -> configured header
                const effectiveSession = (currentChatData && currentChatData.sessionId) ? currentChatData.sessionId : (sessionId || (API_CONFIG.headers && API_CONFIG.headers.session) || '');
                console.log('Effective session for API call:', effectiveSession);
                if (effectiveSession) headers.session = effectiveSession;

                // Debug: log headers about to be sent (mask token)
                try {
                    const debugHeaders = { ...headers };
                    if (debugHeaders.token) debugHeaders.token = '***MASKED***';
                    console.log(`Calling API for chat ${currentChatData?.id || 'unknown'} with headers:`, debugHeaders);
                } catch (e) { }

                const response = await fetch(API_CONFIG.baseUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({ message: message })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.log('Base /chat API Response:', data);

                // Central handler will update session, decide if follow-ups should use socket, and render
                try {
                    handleAPIResponse(data);
                } catch (e) {
                    console.warn('handleAPIResponse threw:', e);
                }

                return data;
            } catch (error) {
                console.error('API call failed:', error);
                throw error;
            }
        }

        // Continue action via socket (replace HTTP /continue calls)
        // The backend will process the continue request and emit processing updates
        // back to the client using the session-specific events. This function
        // emits an appropriate socket event instead of calling the /c HTTP API.
        async function makeContinueAPICall(selectedValue, tag, followedByValue) {
            try {
                console.log('Triggering continue via socket with:', {
                    selected: selectedValue,
                    tag: tag,
                    followedBy: followedByValue
                });

                if (!socket) {
                    throw new Error('Socket not initialized');
                }

                if (!socket.connected) {
                    console.warn('Socket not connected, cannot send continue via socket');
                    throw new Error('Socket not connected');
                }

                // Map tag to server-side event names used elsewhere in this client
                const normalizedTag = (tag || '').toString().toLowerCase();
                let eventName = 'user_selection';
                if (normalizedTag.includes('location') || normalizedTag === 'selected_location') eventName = 'location';
                else if (normalizedTag.includes('client') || normalizedTag === 'selected_client') eventName = 'selected_client';
                else if (normalizedTag.includes('auth_service') || normalizedTag === 'selected_service') eventName = 'auth_service';

                const payload = {
                    selected: selectedValue,
                    tag: tag,
                    followedBy: followedByValue,
                    sessionId: (currentChatData && currentChatData.sessionId) ? currentChatData.sessionId : sessionId
                };

                // Use socket ack when available (with timeout) and return a promise
                return new Promise((resolve) => {
                    try {
                        // Use a short timeout; server will still emit processing updates
                        // via the session-specific events that setupProcessingListener listens to.
                        if (typeof socket.timeout === 'function') {
                            socket.timeout(5000).emit(eventName, payload, (err, resp) => {
                                if (err) {
                                    console.warn('Socket emit timeout or error:', err);
                                    // Resolve with a lightweight object; processing updates will come via socket
                                    resolve({ status: 'sent', ack: false });
                                } else {
                                    console.log('Socket emit ack:', resp);
                                    resolve(resp || { status: 'sent', ack: true });
                                }
                            });
                        } else {
                            // Fallback when ack API is not available - fire-and-forget
                            socket.emit(eventName, payload);
                            resolve({ status: 'sent', ack: false });
                        }
                    } catch (e) {
                        console.error('Socket emit failed:', e);
                        resolve({ status: 'sent', ack: false });
                    }
                });
            } catch (error) {
                console.error('Continue (socket) failed:', error);
                addMessage(" Failed to complete the booking. Please try again.");
                // Keep compatibility: return an object to indicate failure
                return { error: true, message: error.message };
            }
        }

        // ==================== Helper Functions ====================
        function shouldTriggerContinueAPI(response) {
            // Check for 202 status code response with followedBy field
            if (response.detail && response.detail.followedBy) {
                console.log('Found followedBy in response.detail:', response.detail.followedBy);
                return true;
            }

            // Check for direct followedBy field
            if (response.followedBy) {
                console.log('Found followedBy in response:', response.followedBy);
                return true;
            }

            return false;
        }

        // Function to get appropriate icon for different types
        function getTypeIcon(type) {
            const typeLower = type.toLowerCase();
            if (typeLower.includes('auth') || typeLower.includes('service')) return '';
            if (typeLower.includes('client') || typeLower.includes('patient')) return '';
            if (typeLower.includes('doctor') || typeLower.includes('therapist') || typeLower.includes('physician')) return '';
            if (typeLower.includes('location') || typeLower.includes('place') || typeLower.includes('room')) return '';
            if (typeLower.includes('time') || typeLower.includes('slot') || typeLower.includes('hour')) return '';
            if (typeLower.includes('date') || typeLower.includes('day') || typeLower.includes('appointment')) return '';
            if (typeLower.includes('service') || typeLower.includes('treatment') || typeLower.includes('therapy')) return '';
            if (typeLower.includes('duration') || typeLower.includes('length')) return '';
            return ''; // Default icon
        }

        // Function to get appropriate subtitle for different types
        function getTypeSubtitle(type, itemName) {
            const typeLower = type.toLowerCase();
            if (typeLower.includes('client') || typeLower.includes('patient')) return 'Select this client for appointment';
            if (typeLower.includes('doctor') || typeLower.includes('therapist')) return 'Available for consultation';
            if (typeLower.includes('location') || typeLower.includes('room')) return 'Available location';
            if (typeLower.includes('time') || typeLower.includes('slot')) return 'Available time slot';
            if (typeLower.includes('date') || typeLower.includes('day')) return 'Available date';
            if (typeLower.includes('service') || typeLower.includes('treatment')) return 'Healthcare service';
            return `Select this ${type.toLowerCase()}`;
        }

        // Helper to format option names by removing date tokens (YYYY-MM-DD)
        // Only applies formatting if the string contains '|' or '=>'
        function formatOptionName(optionName) {
            if (!optionName || typeof optionName !== 'string') return optionName;

            // Only process if it contains '|' or '=>'
            if (!optionName.includes('|') && !optionName.includes('=>')) return optionName;

            const [left, right] = optionName.split('=>');

            // Regex for date format (YYYY-MM-DD)
            const dateRegex = /^\d{4}-\d{2}-\d{2}$/;

            // Clean the left part by removing date tokens
            const cleanedLeft = left
                .split('|')
                .map(p => p.trim())
                .filter(p => p && !dateRegex.test(p))
                .join(' | ');

            // Combine cleaned left + right (if exists)
            const rebuilt = `${cleanedLeft.trim()}${right ? ' => ' + right.trim() : ''}`;

            return rebuilt.trim();
        }

        // Small helper to truncate text safely
        function truncateText(text, maxLen) {
            if (!text) return '';
            const t = String(text).trim();
            if (t.length <= maxLen) return t;
            return t.substring(0, maxLen - 3) + '...';
        }

        // Function to determine selection message format using markdown
        function getSelectionMessage(type, itemName) {
            const typeLower = type.toLowerCase();
            if (typeLower.includes('client') || typeLower.includes('patient')) return `I select client: ${itemName}`;
            if (typeLower.includes('doctor') || typeLower.includes('therapist')) return `I select doctor: ${itemName}`;
            if (typeLower.includes('location')) return `I select location: ${itemName}`;
            if (typeLower.includes('time')) return `I select time: ${itemName}`;
            if (typeLower.includes('date')) return `I select date: ${itemName}`;
            if (typeLower.includes('service')) return `I select service: ${itemName}`;

            // Use API tag if available, otherwise fallback to generic
            if (currentResponseTag) {
                return `I select ${currentResponseTag}: ${itemName}`;
            }
            return `I select ${type}: ${itemName}`;
        }

        // ==================== Employee Card Creation Function ====================
        function createEmployeeCard(employee, index) {
            const card = document.createElement('div');
            card.className = 'employee-card';

            // Get match score and determine style
            const matchScore = Math.round((employee.match_score || 0) * 100);
            let matchClass = 'employee-match-score';
            if (matchScore >= 50) matchClass += '';
            else if (matchScore >= 20) matchClass += ' low-match';
            else matchClass += ' no-match';

            // Parse languages
            const languages = employee.LanguageNames ? employee.LanguageNames.map(lang => lang.trim()) : [];

            // Get initials for avatar
            const initials = employee.EmployeeFullName ?
                employee.EmployeeFullName.split(' ').map(n => n[0]).join('').substring(0, 2).toUpperCase() : 'EMP';

            // Format distance
            const distance = employee.DistanceInMiles !== undefined ?
                `${employee.DistanceInMiles.toFixed(1)} miles` : 'Location not specified';

            card.innerHTML = `
                ${employee.SuggestCriteria && employee.SuggestCriteria.includes('TreatmentTeam') ? `
                    <div class="employee-treatment-team-member-badge">
                        <div class="employee-treatment-team-member-icon"></div>
                        <div class="employee-treatment-team-member-text">Treatment Team Member</div>
                    </div>
                ` : ''}

                <div class="employee-header">
                    <div class="employee-avatar">${initials}</div>
                    <div class="employee-main-info">
                        <div class="employee-name">${employee.EmpName ? employee.EmpName : employee.EmployeeFullName || 'Employee'}</div>
                        <div class="${matchClass}">
                             ${matchScore}% Match
                        </div>
                    </div>
                </div>

                <div class="employee-details">
                    <div class="employee-detail-item">
                        <div class="employee-detail-icon"></div>
                        <div class="employee-detail-text">${employee.GenderType ? employee.GenderType : employee.GenderName || 'Not specified'}</div>
                    </div>
                    <div class="employee-detail-item">
                        <div class="employee-detail-icon"></div>
                        <div class="employee-detail-text">${distance}</div>
                    </div>
                    <div class="employee-detail-item">
                        <div class="employee-detail-icon"></div>
                        <div class="employee-detail-text">ID: ${employee.EmployeeId}</div>
                    </div>
                    <div class="employee-detail-item">
                        <div class="employee-detail-icon"></div>
                        <div class="employee-detail-text">${employee.SuggestCriteria?.length > 0 ? employee.SuggestCriteria.map(item => item.replace(/([a-z])([A-Z])/g, '$1 $2')).join(', ') : 'Standard Match'}</div>
                    </div>
                </div>

              

                ${employee.AuthName && employee.AuthName !== 'None' ? `
                    <div class="employee-auth-info">
                        <div class="employee-auth-title">
                            <span></span> Authorization
                        </div>
                        <div class="employee-auth-name">${employee.AuthName}</div>
                    </div>
                ` : ''}

                ${employee.TreatmentTypeName == ":" ? `
                    <div class="employee-treatment-info">
                        <div class="employee-treatment-title">
                            <span></span> Treatment Type
                        </div>
                        <div class="employee-treatment-name">${employee.TreatmentTypeName}</div>
                    </div>
                ` : ''}
            `;

            return card;
        }

        

        // ==================== API Response Handler ====================
        function handleAPIResponse(response) {
            console.log('API Response:', response);

            // Update session ID if available
            // Try multiple locations for session value
            const extractedSession = response.session || (response.detail && response.detail.session) ||
                (response.message && response.message.session) || (response.data && response.data.session) || '';

            if (extractedSession) {
                sessionId = extractedSession;
                API_CONFIG.headers.session = sessionId;
                // Persist session into the active chat for per-chat session support
                if (currentChatData && currentChatData.id) {
                    currentChatData.sessionId = sessionId;
                    // Also save to localStorage via saveCurrentChatState/saveCurrentChat
                    saveCurrentChat();
                }
                console.log(`Updated session ID for chat ${currentChatData?.id || 'unknown'}: ${sessionId}`);

                // Setup socket listener for the new session
                if (socket && socket.connected) {
                    setupProcessingListener(sessionId);
                }
            }

            // Handle nested message structure
            let actualMessage = response.message;
            let messageDetails = null;

            if (response.message && typeof response.message === 'object') {
                // Handle nested message object
                actualMessage = response.message.message;
                messageDetails = response.message;
                console.log('Found nested message structure:', messageDetails);
            }

            // Store followedBy value when available
            if (response.detail && response.detail.followedBy !== undefined) {
                followedBy = response.detail.followedBy;
                console.log('Stored followedBy value from detail:', followedBy);
            } else if (response.followedBy !== undefined) {
                followedBy = response.followedBy;
                console.log('Stored followedBy value:', followedBy);
            }

            // Check if we should trigger continue API for future selections
            const shouldUseContinueAPI = shouldTriggerContinueAPI(response);
            console.log('Should use Continue API:', shouldUseContinueAPI);

            // Handle 202 status code response with detail object
            if (response.detail) {
                // Store the tag from API response
                if (response.detail.tag) {
                    console.log('Response Tag:', response.detail.tag);
                    currentResponseTag = response.detail.tag;
                }

                // Handle message display
                if (response.detail.message) {
                    // Check if there are options to display
                    if (response.detail.options && Array.isArray(response.detail.options) && response.detail.options.length > 0) {
                        // Use the tag from API response or fallback to generic
                        const type = response.detail.tag || 'Option';
                        insertOptionsIntoTypingIndicator({ response: response.detail.options, content: response.detail.message || '' }, type, shouldUseContinueAPI);
                    } else {
                        // Just show the message - COT will be included automatically if available from live processing
                        addMessage(response.detail.message, false);
                    }
                }
            }
            // Handle responses with nested message structure
            else if (messageDetails) {
                // Check for specific message types
                if (actualMessage) {
                    addMessage(actualMessage, false);
                }
            }
            // Handle direct response with options field
            else if (response.options && Array.isArray(response.options) && response.options.length > 0) {
                // Store the tag from API response
                if (response.tag) {
                    currentResponseTag = response.tag;
                }

                // Determine the type from tag or try to infer from options
                let type = response.tag || 'Option';

                // Try to infer type from first option if no tag provided
                if (!response.tag && response.options.length > 0) {
                    const firstOption = response.options[0];
                    if (typeof firstOption === 'object') {
                        if (firstOption.specialty || firstOption.doctor_name) type = 'Doctor';
                        else if (firstOption.client_name || firstOption.patient_name) type = 'Client';
                        else if (firstOption.location_name || firstOption.room) type = 'Location';
                        else if (firstOption.time_slot || firstOption.slot) type = 'Time';
                        else if (firstOption.date || firstOption.appointment_date) type = 'Date';
                        else if (firstOption.service_name || firstOption.treatment) type = 'Service';
                    }
                }

                // Display message first if available, then render options
                if (response.message) {
                    insertOptionsIntoTypingIndicator({ response: response.options, content: response.message }, type, shouldUseContinueAPI);
                } else {
                    insertOptionsIntoTypingIndicator({ response: response.options, content: '' }, type, shouldUseContinueAPI);
                }
            }
            // Handle 200 status code response or other formats
            else if (actualMessage) {
                // Store the tag from API response
                if (response.tag) {
                    currentResponseTag = response.tag;
                }

                // Check for therapist conflict message
                else if (actualMessage && actualMessage.includes("Therapist already has a session")) {
                    addMessage(" " + actualMessage + "\n\nPlease select a different time slot or date for your appointment.", false);
                }
                // Display regular message
                else {
                    addMessage(actualMessage, false);
                }

            }
            // Handle case where response only contains options array
            else if (response.options && Array.isArray(response.options)) {
                const type = currentResponseTag || 'Option';
                insertOptionsIntoTypingIndicator({ response: response.options, content: 'Please select from the following options:' }, type, shouldUseContinueAPI);
            }
            // Fallback for any other response format
            else {
                // addMessage("I received your message. Please let me know how I can help you further with your healthcare needs.", false);
            }
        }

        // ==================== Main Message Handler ====================
        async function handleMessage(message) {

            if (isProcessing) {
                return; // Prevent multiple simultaneous requests
            }

            addMessage(message, true);
            messageInput.value = '';
            isProcessing = true;

            const typingIndicator = showTypingIndicator();

            try {
                const response = await makeAPICall(message);
                // If the response indicates follow-up processing, it will arrive via socket events.
                // For synchronous responses, handleAPIResponse has already run inside makeAPICall.
                removeTypingIndicator();
            } catch (error) {
                removeTypingIndicator();
                addMessage("I apologize, but I'm having trouble connecting to our healthcare system right now. Please try again in a moment, or contact our support team if the issue persists.", false);
                console.error('Error handling message:', error);
            } finally {
                isProcessing = false;
            }
        }

        // Show welcome message when chat is opened
        function showWelcomeMessage() {
            const welcomeMessage = `####  Welcome to Healthcare Assistant!

##### How can I assist you with your healthcare needs today?
`;

            addMessage(welcomeMessage);
        }

        // ==================== Event Listeners ====================
        const chatContainer = document.getElementById('chatContainer');
        const closeBtn = document.getElementById('closeBtn');
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const newChatBtn = document.getElementById('newChatBtn');
        const savedChatsList = document.getElementById('savedChatsList');

        // Enhance header controls at runtime (non-breaking)
        (() => {
            const controls = document.querySelector('.chat-controls');
            if (controls && !document.getElementById('themeToggle')) {
                const dot = document.createElement('div');
                dot.id = 'connectionDot';
                dot.className = 'connection-indicator';
                controls.prepend(dot);
                // const t = document.createElement('button');
                // t.id = 'themeToggle';
                // t.className = 'theme-toggle';
                // t.type = 'button';
                // t.innerHTML = '<span></span><span>Theme</span>';
                // controls.prepend(t);
            }
        })();

        newChatBtn.addEventListener('click', createNewChat);

        sendBtn.addEventListener('click', () => {
            const message = messageInput.value.trim();
            if (message && !isProcessing) {
                handleMessage(message);
            }
        });

        // Auto-resize textarea and keyboard handling
        function autoResizeTextarea(el) {
            el.style.height = 'auto';
            el.style.height = Math.min(el.scrollHeight, 160) + 'px';
        }
        messageInput.addEventListener('input', () => autoResizeTextarea(messageInput));
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const message = messageInput.value.trim();
                if (message && !isProcessing) {
                    handleMessage(message);
                }
            } else if (e.key === 'Enter' && e.shiftKey) {
                // allow newline
                setTimeout(() => autoResizeTextarea(messageInput), 0);
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                const message = messageInput.value.trim();
                if (message && !isProcessing) {
                    handleMessage(message);
                }
            }
        });

        closeBtn.addEventListener('click', () => {
            // Save current chat before closing
            saveCurrentChat();
            // In a real application, you might want to hide the chat or redirect
            console.log('Chat closed - current chat saved');
        });

        // Theme toggle
        // document.getElementById('themeToggle').addEventListener('click', () => {
        //     const current = document.documentElement.getAttribute('data-theme') || 'light';
        //     applyTheme(current === 'light' ? 'dark' : 'light');
        // });

        // Scroll to bottom logic
        const scrollBtn = document.getElementById('scrollToBottomBtn');
        function atBottom() {
            const threshold = 20;
            return chatMessages.scrollTop + chatMessages.clientHeight >= chatMessages.scrollHeight - threshold;
        }
        function updateScrollButton() {
            if (!scrollBtn) return;
            if (atBottom()) scrollBtn.classList.remove('show');
            else scrollBtn.classList.add('show');
        }
        chatMessages.addEventListener('scroll', updateScrollButton);
        scrollBtn?.addEventListener('click', () => {
            chatMessages.scrollTop = chatMessages.scrollHeight;
            updateScrollButton();
        });

        // Auto-save current chat periodically
        setInterval(() => {
            if (currentChatData.messages.length > 0) {
                saveCurrentChat();
            }
        }, 30000); // Save every 30 seconds

        // Save chat when page is about to unload (browser close/refresh)
        window.addEventListener('beforeunload', (event) => {
            // Save current chat state
            saveCurrentChat();

            // Save current scroll position
            if (currentChatData.id && chatMessages) {
                const scrollPosition = chatMessages.scrollTop;
                // Update the chat data with current scroll position
                const savedChats = getSavedChats();
                const chatIndex = savedChats.findIndex(chat => chat.id === currentChatData.id);
                if (chatIndex !== -1) {
                    savedChats[chatIndex].scrollPosition = scrollPosition;
                    localStorage.setItem('healthcareChats', JSON.stringify(savedChats));
                }
            }

            console.log(' Saved chat state before browser close/refresh');
            updateHeaderToComplete();
            // Note: Modern browsers ignore custom messages in beforeunload
            // The function just needs to save data, no return value needed
        });

        // Additional save on visibility change (when user switches tabs)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && currentChatData.messages.length > 0) {
                saveCurrentChat();
                console.log(' Saved chat state on tab switch');
                updateHeaderToComplete();
            }
        });

        // ==================== Initialize Application ====================
        document.addEventListener('DOMContentLoaded', () => {
            // Clean up any stale data first
            cleanupStaleData();

            // Check if this is a refresh (browser reload)
            const isRefresh = performance.navigation && performance.navigation.type === 1;
            const storedChatId = localStorage.getItem('currentChatId');
            const hasExistingChats = getSavedChats().length > 0;

            if (isRefresh && storedChatId) {
                console.log(' Browser refresh detected, restoring chat:', storedChatId);
                // Show notification that chat was restored (optional)
                // showRefreshNotification();
            }

            // Initialize socket connection
            initializeSocket();

            // IMPORTANT: Only call initializeSession if there are no saved chats
            // If we have saved chats, initializeChat() will restore the session from the chat data
            if (!hasExistingChats) {
                console.log(' No saved chats, initializing new session');
                initializeSession();
            } else {
                console.log(' Saved chats found, skipping session initialization (will restore from chat data)');
            }

            // Initialize the chat system (will restore previous chat if exists)
            initializeChat();

            // Initialize connection status
            updateConnectionStatus(false); // Start as disconnected until socket connects

            // Focus the message input
            messageInput.focus();
            autoResizeTextarea(messageInput);
            initTheme();
            updateScrollButton();
        });

        // ==================== Development & Testing Functions ====================
        // Global functions for testing socket functionality from browser console
        window.testSocketProcessing = function (testMessage) {
            if (!sessionId) {
                console.warn('No active session. Start a chat first.');
                return;
            }

            console.log(`Testing socket processing update for session: ${sessionId}`);

            // Show typing indicator first
            if (!currentTypingIndicator) {
                showTypingIndicator();
            }

            // Simulate receiving a processing update
            const testData = {
                thought: testMessage || "Testing chain of thoughts functionality",
                step: "Analyzing user request",
                status: "Processing"
            };

            updateTypingIndicatorText(testData);

            console.log('Test processing update sent. Check the typing indicator.');
        };

        window.testSocketConnection = function () {
            const connectionDot = document.getElementById('connectionDot');
            const status = {
                connected: socket?.connected || false,
                id: socket?.id || 'N/A',
                sessionId: sessionId || 'No session',
                currentTypingIndicator: !!currentTypingIndicator,
                connectionDotStatus: connectionDot?.classList.contains('connected') || false,
                socketURL: SOCKET_URL
            };

            console.log('Socket connection status:', status);

            if (socket && socket.connected && sessionId) {
                console.log(`Active listener for: ${sessionId}process`);
            }

            return status;
        };

        // Test function to verify COT preservation
        window.testCOTPreservation = function () {
            console.log('Current Chain of Thoughts:', currentChainOfThoughts);
            console.log('COT Length:', currentChainOfThoughts.length);

            // Add some test COT steps
            currentChainOfThoughts.push(
                { stepId: 'test1', message: 'Step 1: Analyzing user request', completed: true },
                { stepId: 'test2', message: 'Step 2: Processing data', completed: true },
                { stepId: 'test3', message: 'Step 3: Generating response', completed: false }
            );

            console.log('Added test COT steps:', currentChainOfThoughts);

            // Test adding a bot message - should automatically include COT
            addMessage('This is a test bot message that should include COT.', false);

            console.log('COT after adding bot message:', currentChainOfThoughts);
            return currentChainOfThoughts;
        };

        // Test function to simulate COT container preservation
        window.testCOTContainer = function () {
            console.log('Testing COT container preservation...');

            // Show typing indicator to create COT container
            const typingIndicator = showTypingIndicator();
            console.log('Created typing indicator with COT container');

            // Simulate some COT steps
            const chainContainer = typingIndicator.querySelector('.chain-container');
            if (chainContainer) {
                // Add some test steps to the dynamic container
                for (let i = 1; i <= 3; i++) {
                    const stepDiv = document.createElement('div');
                    stepDiv.className = 'chain-item completed';
                    stepDiv.innerHTML = `
                <div class="chain-check"></div>
                <div class="chain-text">Test COT Step ${i}</div>
            `;
                    chainContainer.appendChild(stepDiv);
                }
                console.log('Added test COT steps to container');
            }

            // Remove typing indicator (should preserve COT)
            setTimeout(() => {
                removeTypingIndicator();
                console.log('Removed typing indicator - COT should be preserved');

                // Add a bot message (should reuse the COT container)
                // setTimeout(() => {
                //     addMessage('This response should show in the same container as the COT!', false);
                //     console.log('Added bot message - should reuse COT container');
                // }, 500);
            }, 1000);
        };

        // Test function for unified panel with different COT states
        window.testUnifiedPanel = function () {
            console.log('Testing unified COT-Response panel...');

            // Create test COT data
            currentChainOfThoughts = [
                { stepId: 'step1', message: ' Analyzing user query and context', completed: true },
                { stepId: 'step2', message: ' Processing information and generating insights', completed: true },
                { stepId: 'step3', message: ' Formulating comprehensive response', completed: true },
                { stepId: 'step4', message: ' Finalizing output with professional formatting', completed: true }
            ];

            // Add a message that will create the unified panel
            addMessage('## Healthcare Consultation Summary\n\nBased on the analysis above, here are the key recommendations:\n\n### Treatment Plan\n1. **Immediate Care**: Monitor vital signs\n2. **Medication**: Prescribed dosage as indicated\n3. **Follow-up**: Schedule in 2 weeks\n\n> This integrated approach ensures comprehensive care delivery.', false);

            console.log('Unified panel created with test COT and response');
        };

        // ==================== Export Functions ====================
        // Global function to make copyCodeToClipboard available
        window.copyCodeToClipboard = function (button) {
            const codeBlock = button.closest('.markdown-code-block').querySelector('code');
            const text = codeBlock.textContent;

            navigator.clipboard.writeText(text).then(() => {
                const originalText = button.textContent;
                button.textContent = ' Copied!';
                button.style.background = '#4CAF50';

                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy code:', err);
                button.textContent = ' Failed';
                setTimeout(() => {
                    button.textContent = ' Copy';
                }, 2000);
            });
        };

        // Export functions for external use if needed
        window.healthcareChat = {
            handleMessage,
            renderSelectionOptionsReadOnly,
            makeContinueAPICall,
            parseMarkdownContent,
            createNewChat,
            loadChat,
            deleteChat,
            saveCurrentChat,
            // COT Management functions
            getCOTForMessage,
            storeCOTForMessage,
            deleteCOTForMessage,
            getAllCOTForChat,
            getCOTStatistics,
            // Expose storage for debugging
            getCOTStorage: () => cotStorage,
            getCurrentChatData: () => currentChatData
        };

        // Console helper for COT inspection
        window.inspectCOT = function (messageId) {
            if (messageId) {
                const cot = getCOTForMessage(messageId);
                console.log(` COT for message ${messageId}:`, cot);
                return cot;
            } else {
                console.log(' COT Statistics:', getCOTStatistics());
                console.log(' All COT Data:', getAllCOTForChat());
                return getAllCOTForChat();
            }
        };

        // Console helper to list all messages with COT
        window.listMessagesWithCOT = function () {
            const messagesWithCOT = currentChatData.messages.filter(m => m.hasCOT);
            console.log(` Messages with COT (${messagesWithCOT.length}):`, messagesWithCOT.map(m => ({
                id: m.id,
                cotId: m.cotId,
                content: m.content.substring(0, 50) + '...',
                cotSteps: cotStorage[m.cotId]?.length || 0
            })));
            return messagesWithCOT;
        };
    </script>
</body>

</html>
